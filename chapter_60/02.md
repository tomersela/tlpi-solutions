# is_echo_sv_mod2.c
```C
--- ./is_echo_sv.c	2025-09-26 13:33:47.554827968 +0300
+++ ./is_echo_sv_mod2.c	2025-09-26 22:44:39.565444751 +0300
@@ -8,11 +8,16 @@
 * the file COPYING.gpl-v3 for details.                                    *
 \*************************************************************************/
 
-/* Listing 60-4 */
+/* Exercise 60-2 */
 
-/* is_echo_sv.c
+/* is_echo_sv_mod2.c
 
-   An implementation of the TCP "echo" service.
+   An implementation of the TCP "echo" service that can be run either
+   as a standalone daemon or as an inetd service.
+
+   Usage:
+   - Standalone mode: ./is_echo_sv_mod2
+   - inetd mode: ./is_echo_sv_mod2 -i
 
    NOTE: this program must be run under a root login, in order to allow the
    "echo" port (7) to be bound. Alternatively, for test purposes, you can
@@ -24,6 +29,8 @@
 #include <signal.h>
 #include <syslog.h>
 #include <sys/wait.h>
+#include <string.h>
+#include <unistd.h>
 #include "become_daemon.h"
 #include "inet_sockets.h"       /* Declarations of inet*() socket functions */
 #include "tlpi_hdr.h"
@@ -42,16 +49,16 @@
     errno = savedErrno;
 }
 
-/* Handle a client request: copy socket input back to socket */
+/* Handle a client request: copy input to output */
 
 static void
-handleRequest(int cfd)
+handleRequest(int rfd, int wfd)
 {
     char buf[BUF_SIZE];
     ssize_t numRead;
 
-    while ((numRead = read(cfd, buf, BUF_SIZE)) > 0) {
-        if (write(cfd, buf, numRead) != numRead) {
+    while ((numRead = read(rfd, buf, BUF_SIZE)) > 0) {
+        if (write(wfd, buf, numRead) != numRead) {
             syslog(LOG_ERR, "write() failed: %s", strerror(errno));
             exit(EXIT_FAILURE);
         }
@@ -68,7 +75,24 @@
 {
     int lfd, cfd;               /* Listening and connected sockets */
     struct sigaction sa;
+    int inetdMode = 0;
+
+    /* Check for -i option (inetd mode) */
+    if (argc == 2 && strcmp(argv[1], "-i") == 0) {
+        inetdMode = 1;
+    } else if (argc != 1) {
+        fprintf(stderr, "Usage: %s [-i]\n", argv[0]);
+        fprintf(stderr, "  -i  run in inetd mode\n");
+        exit(EXIT_FAILURE);
+    }
+
+    if (inetdMode) {
+        /* inetd mode: handle single client on stdin/stdout */
+        handleRequest(STDIN_FILENO, STDOUT_FILENO);
+        exit(EXIT_SUCCESS);
+    }
 
+    /* Standalone mode: run as daemon */
     if (becomeDaemon(0) == -1)
         errExit("becomeDaemon");
 
@@ -105,7 +129,7 @@
 
         case 0:                         /* Child */
             close(lfd);                 /* Unneeded copy of listening socket */
-            handleRequest(cfd);
+            handleRequest(cfd, cfd);
             _exit(EXIT_SUCCESS);
 
         default:                        /* Parent */

```

# Testing
I don't have inetd on the Debian distribution I'm using, so I only tested the stdin/stdout interface (which implements the required contract for inetd):

```
$ echo "hello world" | ./is_echo_sv_mod2 -i
hello world
$ 
```

It's also important to verify there are no regressions in the standalone daemon mode:

```
$ echo "test" | nc -q 1 localhost 7
test
$ 
```
