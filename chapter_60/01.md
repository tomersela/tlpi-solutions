# is_echo_sv_mod.c
In order to limit the number of concurrent connections to 10, I've used a POSIX Semaphore.

```C
/*************************************************************************\
*                  Copyright (C) Michael Kerrisk, 2024.                   *
*                                                                         *
* This program is free software. You may use, modify, and redistribute it *
* under the terms of the GNU General Public License as published by the   *
* Free Software Foundation, either version 3 or (at your option) any      *
* later version. This program is distributed without any warranty.  See   *
* the file COPYING.gpl-v3 for details.                                    *
\*************************************************************************/

/* Listing 60-4 */

/* is_echo_sv.c

   An implementation of the TCP "echo" service.

   NOTE: this program must be run under a root login, in order to allow the
   "echo" port (7) to be bound. Alternatively, for test purposes, you can
   replace the SERVICE name below with a suitable unreserved port number
   (e.g., "51000"), and make a corresponding change in the client.

   See also is_echo_cl.c.
*/
#include <signal.h>
#include <syslog.h>
#include <semaphore.h>
#include <sys/wait.h>
#include "become_daemon.h"
#include "inet_sockets.h"       /* Declarations of inet*() socket functions */
#include "tlpi_hdr.h"

#define SERVICE "echo"          /* Name of TCP service */
#define BUF_SIZE 4096

static sem_t sem;

static void             /* SIGCHLD handler to reap dead child processes */
grimReaper(int sig)
{
    int savedErrno;             /* Save 'errno' in case changed here */

    savedErrno = errno;
    while (waitpid(-1, NULL, WNOHANG) > 0)
        continue;
    errno = savedErrno;
}

/* Handle a client request: copy socket input back to socket */

static void
handleRequest(int cfd)
{
    char buf[BUF_SIZE];
    ssize_t numRead;

    while ((numRead = read(cfd, buf, BUF_SIZE)) > 0) {
        if (write(cfd, buf, numRead) != numRead) {
            syslog(LOG_ERR, "write() failed: %s", strerror(errno));
            exit(EXIT_FAILURE);
        }
    }

    if (numRead == -1) {
        syslog(LOG_ERR, "Error from read(): %s", strerror(errno));
        exit(EXIT_FAILURE);
    }
}

int
main(int argc, char *argv[])
{
    int lfd, cfd;               /* Listening and connected sockets */
    struct sigaction sa;

    if (becomeDaemon(0) == -1)
        errExit("becomeDaemon");

    /* Establish SIGCHLD handler to reap terminated child processes */

    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = grimReaper;
    if (sigaction(SIGCHLD, &sa, NULL) == -1) {
        syslog(LOG_ERR, "Error from sigaction(): %s", strerror(errno));
        exit(EXIT_FAILURE);
    }

    lfd = inetListen(SERVICE, 10, NULL);
    if (lfd == -1) {
        syslog(LOG_ERR, "Could not create server socket (%s)", strerror(errno));
        exit(EXIT_FAILURE);
    }

    if (sem_init(&sem, 1, 10) == -1)
        errExit("sem_init");

    for (;;) {
        cfd = accept(lfd, NULL, NULL);  /* Wait for connection */
        if (cfd == -1) {
            syslog(LOG_ERR, "Failure in accept(): %s", strerror(errno));
            exit(EXIT_FAILURE);
        }

        sem_wait(&sem);

        /* Handle each client request in a new child process */

        switch (fork()) {
        case -1:
            syslog(LOG_ERR, "Can't create child (%s)", strerror(errno));
            close(cfd);                 /* Give up on this client */
            sem_post(&sem);
            break;                      /* May be temporary; try next client */

        case 0:                         /* Child */
            close(lfd);                 /* Unneeded copy of listening socket */
            handleRequest(cfd);
            sem_post(&sem);
            _exit(EXIT_SUCCESS);

        default:                        /* Parent */
            close(cfd);                 /* Unneeded copy of connected socket */
            break;                      /* Loop to accept next connection */
        }
    }
}

```

# Testing
The following bash script create 20 connections, but use `sleep` to hold each connection for 4 seconds.<br/>
Then it monitors the number of created processes (we assume running the server and this client script on the same machine).

```bash
#!/bin/bash

for i in {1..20}; do
    {
        echo "Connection $i starting"
        sleep 4  # leep connection alive to demonstrate semaphore limiting
        echo "Connection $i ending"
    } | nc -q 0 localhost 7 &
    echo "Started connection $i"
    sleep 0.1
done

# monitor for 6 seconds to see semaphore limiting the number of child processes created
echo "Number child processes:"
for i in {1..30}; do
    server_pid=$(pgrep -x is_echo_sv_mod | head -1)
    if [ -n "$server_pid" ]; then
        count=$(pgrep -P $server_pid 2>/dev/null | wc -l)
    else
        count=0
    fi
    echo "$(date '+%H:%M:%S') - Child processes: $count"
    sleep 0.2
done
echo "Done"
```

## Running the test
```
$ sudo ./is_echo_sv_mod & # starting server
$ ./is_echo_sv_mod_test.sh
Started connection 1
Connection 1 starting
Started connection 2
Connection 2 starting
Started connection 3
Connection 3 starting
Started connection 4
Connection 4 starting
Started connection 5
Connection 5 starting
Started connection 6
Connection 6 starting
Started connection 7
Connection 7 starting
Started connection 8
Connection 8 starting
Started connection 9
Connection 9 starting
Started connection 10
Connection 10 starting
Started connection 11
Started connection 12
Started connection 13
Started connection 14
Started connection 15
Started connection 16
Started connection 17
Started connection 18
Started connection 19
Started connection 20
Number child processes:
22:27:33 - Child processes: 10
22:27:33 - Child processes: 10
22:27:33 - Child processes: 10
22:27:34 - Child processes: 10
22:27:34 - Child processes: 10
22:27:34 - Child processes: 10
22:27:34 - Child processes: 10
22:27:34 - Child processes: 10
22:27:35 - Child processes: 10
Connection 11 starting
Connection 12 starting
22:27:35 - Child processes: 10
Connection 13 starting
Connection 14 starting
Connection 15 starting
22:27:35 - Child processes: 9
Connection 16 starting
Connection 17 starting
22:27:35 - Child processes: 10
Connection 18 starting
Connection 19 starting
22:27:36 - Child processes: 10
Connection 20 starting
22:27:36 - Child processes: 9
Connection 13 ending
22:27:36 - Child processes: 7
22:27:36 - Child processes: 5
22:27:37 - Child processes: 2
22:27:37 - Child processes: 0
22:27:37 - Child processes: 0
22:27:37 - Child processes: 0
22:27:37 - Child processes: 0
22:27:38 - Child processes: 0
22:27:38 - Child processes: 0
22:27:38 - Child processes: 0
22:27:38 - Child processes: 0
22:27:39 - Child processes: 0
22:27:39 - Child processes: 0
22:27:39 - Child processes: 0
22:27:39 - Child processes: 0
22:27:39 - Child processes: 0
Done
$ 
```

We can see the number of child processes never exceeds 10.
