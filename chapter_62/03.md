# Code

## getpass.h
```C
#ifndef GETPASS_H
#define GETPASS_H

#define MAX_PASS_LENGTH 1024

char *getpass(const char *prompt);

#endif // GETPASS_H

```

## getpass.c
```C
#include "tlpi_hdr.h"
#include "tty_functions.h"
#include "getpass.h"


static struct termios userTermios;
                        /* Terminal settings as defined by user */


static void             /* General handler: restore tty settings and exit */
handler(int sig)
{
    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &userTermios) == -1)
        errExit("tcsetattr");
    _exit(EXIT_SUCCESS);
}


static void             /* Handler for SIGTSTP */
tstpHandler(int sig)
{
    struct termios ourTermios;          /* To save our tty settings */
    sigset_t tstpMask, prevMask;
    struct sigaction sa;
    int savedErrno;

    savedErrno = errno;                 /* We might change 'errno' here */

    /* Save current terminal settings, restore terminal to
       state at time of program startup */

    if (tcgetattr(STDIN_FILENO, &ourTermios) == -1)
        errExit("tcgetattr");
    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &userTermios) == -1)
        errExit("tcsetattr");

    /* Set the disposition of SIGTSTP to the default, raise the signal
       once more, and then unblock it so that we actually stop */

    if (signal(SIGTSTP, SIG_DFL) == SIG_ERR)
        errExit("signal");
    raise(SIGTSTP);

    sigemptyset(&tstpMask);
    sigaddset(&tstpMask, SIGTSTP);
    if (sigprocmask(SIG_UNBLOCK, &tstpMask, &prevMask) == -1)
        errExit("sigprocmask");

    /* Execution resumes here after SIGCONT */

    if (sigprocmask(SIG_SETMASK, &prevMask, NULL) == -1)
        errExit("sigprocmask");         /* Reblock SIGTSTP */

    sigemptyset(&sa.sa_mask);           /* Reestablish handler */
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = tstpHandler;
    if (sigaction(SIGTSTP, &sa, NULL) == -1)
        errExit("sigaction");

    /* The user may have changed the terminal settings while we were
       stopped; save the settings so we can restore them later */

    if (tcgetattr(STDIN_FILENO, &userTermios) == -1)
        errExit("tcgetattr");

    /* Restore our terminal settings */

    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &ourTermios) == -1)
        errExit("tcsetattr");

    errno = savedErrno;
}


char *
getpass(const char *prompt)
{
    static char buffer[MAX_PASS_LENGTH];
    struct sigaction sa, prev_quit, prev_int, prev_term, prev_tstp;
    int ttyfd;
    int read_cnt;
    
    printf("%s", prompt);
    fflush(stdout);

    if ((ttyfd = open("/dev/tty", O_RDWR)) == -1)
        errExit("open /dev/tty");

    /* Set handler for SIGQUIT or SIGINT signals to restore the user's terminal settings,
       but only if these signals aren't ignored */
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = handler;

    if (sigaction(SIGQUIT, NULL, &prev_quit) == -1)
        errExit("sigaction");
    if (prev_quit.sa_handler != SIG_IGN)
        if (sigaction(SIGQUIT, &sa, NULL) == -1)
            errExit("sigaction");

    if (sigaction(SIGINT, NULL, &prev_int) == -1)
        errExit("sigaction");
    if (prev_int.sa_handler != SIG_IGN)
        if (sigaction(SIGINT, &sa, NULL) == -1)
            errExit("sigaction");

    if (sigaction(SIGTERM, NULL, &prev_term) == -1)
        errExit("sigaction");
    if (prev_term.sa_handler != SIG_IGN)
        if (sigaction(SIGTERM, &sa, NULL) == -1)
            errExit("sigaction");

    /* Set handler for SIGTSTP to restore user's terminal settings in case the program pause.
       This handler also take care of restoring the program terminal settings on resume */
    sa.sa_handler = tstpHandler;
    if (sigaction(SIGTSTP, NULL, &prev_tstp) == -1)
        errExit("sigaction");
    if (prev_tstp.sa_handler != SIG_IGN)
        if (sigaction(SIGTSTP, &sa, NULL) == -1)
            errExit("sigaction");
    
    // Change terminal mode to Cbreak
    if (ttySetCbreak(ttyfd, &userTermios))
        errExit("ttySetCbreak");

    // read password from terminal
    if ((read_cnt = read(ttyfd, buffer, MAX_PASS_LENGTH - 1)) == -1)
        errExit("read");
    buffer[read_cnt] = '\0';
    if (read_cnt > 0 && buffer[read_cnt - 1] == '\n')
        buffer[read_cnt - 1] = '\0';

    if (tcsetattr(ttyfd, TCSAFLUSH, &userTermios) == -1)
        errExit("tcsetattr()");

    if (close(ttyfd) == -1)
        errExit("close ttyfd");

    // restore signal handlers
    if (sigaction(SIGQUIT, &prev_quit, NULL) == -1)
        errExit("sigaction");
    if (sigaction(SIGINT, &prev_int, NULL) == -1)
        errExit("sigaction");
    if (sigaction(SIGTERM, &prev_term, NULL) == -1)
        errExit("sigaction");
    if (sigaction(SIGTSTP, &prev_tstp, NULL) == -1)
        errExit("sigaction");

    printf("\n"); /* Move to next line since echo was disabled */
    return buffer;
}
```


# Testing

## getpass_test.c
```C
#include "tlpi_hdr.h"
#include "getpass.h"

int
main(int argc, char *argv[])
{
    char *pass;

    pass = getpass("Please enter your password: ");
    printf("Top secret: %s\n", pass);
}

```

## Running
```
$ ./getpass_test
Please enter your password: 
Top secret: Testing 1, 2...
$ 
```
