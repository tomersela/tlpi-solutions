# Code
Implementation of a client-server application that allows remote shell command execution.

- Client connects to server, sends command using `writen()`, closes write half with `shutdown()`, reads output
- Server uses concurrent design with `fork()` for each connection
- Command execution uses `execl("/bin/sh", "sh", "-c", command)` like `system()`
- Output redirection with `dup2()` redirects stdout/stderr to socket
- Uses `writen()` for reliable data transmission
- SIGCHLD handler reaps zombie children, SIGPIPE ignored
- Uses `err_exit()` in child processes for proper cleanup

**WARNING!** No security mechanisms - run the server only in trusted environments with  limited privileges.


## is_shell_sv.c
The server accepts connections and executes commands in child processes:

```c
#include <sys/socket.h>
#include <sys/wait.h>
#include <netdb.h>
#include <signal.h>

#include "tlpi_hdr.h"
#include "rdwrn.h"

#define PORT_NUM "50000"
#define BACKLOG 50
#define BUF_SIZE 4096

static void
handleRequest(int cfd)
{
    char buf[BUF_SIZE];
    ssize_t numRead, totalRead;

    // read command from client until EOF
    totalRead = 0;
    while ((numRead = read(cfd, buf + totalRead, BUF_SIZE - totalRead - 1)) > 0) {
        totalRead += numRead;
        if (totalRead >= BUF_SIZE - 1) {
            // command too long, send error message
            const char *error_msg = "Error: Command too long (max 4095 characters)\n";
            write(cfd, error_msg, strlen(error_msg));
            close(cfd);
            _exit(1);
        }
    }

    if (numRead == -1)
        err_exit("read");

    buf[totalRead] = '\0';  // null-terminate command string

    // duplicate socket file descriptor to stdout and stderr
    if (dup2(cfd, STDOUT_FILENO) == -1)
        err_exit("dup2 stdout");

    if (dup2(cfd, STDERR_FILENO) == -1)
        err_exit("dup2 stderr");

    // close original socket fd since we have duplicates
    if (close(cfd) == -1)
        err_exit("close");

    // execute command using shell
    execl("/bin/sh", "sh", "-c", buf, (char *) NULL);

    // if we get here, exec failed
    _exit(127);
}

static void
sigchldHandler(int sig)
{
    int savedErrno = errno;

    // reap all available zombie children
    while (waitpid(-1, NULL, WNOHANG) > 0)
        continue;

    errno = savedErrno;
}

int
main(int argc, char *argv[])
{
    int lfd, cfd;
    struct addrinfo hints, *result, *rp;
    struct sigaction sa;

    // ignore SIGPIPE signal
    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
        errExit("signal");

    // install SIGCHLD handler to reap zombie children
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;
    sa.sa_handler = sigchldHandler;
    if (sigaction(SIGCHLD, &sa, NULL) == -1)
        errExit("sigaction");

    // create listening socket
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE | AI_NUMERICSERV;

    if (getaddrinfo(NULL, PORT_NUM, &hints, &result) != 0)
        errExit("getaddrinfo");

    // try each address until we successfully bind one
    for (rp = result; rp != NULL; rp = rp->ai_next) {
        lfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        if (lfd == -1)
            continue;

        // enable address reuse
        int optval = 1;
        if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1) {
            close(lfd);
            continue;
        }

        if (bind(lfd, rp->ai_addr, rp->ai_addrlen) == 0)
            break;  // success

        close(lfd);
    }

    if (rp == NULL)
        fatal("Could not bind to any address");

    freeaddrinfo(result);

    if (listen(lfd, BACKLOG) == -1)
        errExit("listen");

    printf("Shell server listening on port %s\n", PORT_NUM);

    // main server loop
    for (;;) {
        cfd = accept(lfd, NULL, NULL);
        if (cfd == -1) {
            if (errno == EINTR)  // interrupted by signal
                continue;
            errExit("accept");
        }

        // handle each client in a separate child process
        switch (fork()) {
        case -1:
            errMsg("fork");
            close(cfd);
            break;

        case 0: // child
            close(lfd);  // child doesn't need listening socket
            handleRequest(cfd);
            // handleRequest() calls exec, so we never return here
            break;

        default: // parent
            close(cfd);  // parent doesn't need connected socket
            break;
        }
    }
}

```


## is_shell_cl.c
The client connects to a server and sends a shell command for execution:

```c
#include <sys/socket.h>
#include <netdb.h>
#include "tlpi_hdr.h"
#include "rdwrn.h"

#define PORT_NUM "50000"

int
main(int argc, char *argv[])
{
    int sfd;
    struct addrinfo hints, *result;
    char *server_host, *command;

    if (argc != 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s server-host 'shell-command'\n", argv[0]);

    server_host = argv[1];
    command = argv[2];

    // create socket and connect to server
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;    // allow IPv4 or IPv6
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_NUMERICSERV;

    if (getaddrinfo(server_host, PORT_NUM, &hints, &result) != 0)
        errExit("getaddrinfo");

    sfd = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    if (sfd == -1)
        errExit("socket");

    if (connect(sfd, result->ai_addr, result->ai_addrlen) == -1)
        errExit("connect");

    freeaddrinfo(result);

    // send command to server using writen() for robust writing
    if (writen(sfd, command, strlen(command)) != strlen(command))
        fatal("writen");

    // close writing half of socket to signal end-of-file to server
    if (shutdown(sfd, SHUT_WR) == -1)
        errExit("shutdown");

    // read and display output from server
    char buf[1024];
    ssize_t numRead;

    while ((numRead = read(sfd, buf, sizeof(buf))) > 0) {
        if (writen(STDOUT_FILENO, buf, numRead) != numRead)
            fatal("writen to stdout");
    }

    if (numRead == -1)
        errExit("read");

    if (close(sfd) == -1)
        errExit("close");

    exit(EXIT_SUCCESS);
}
```


# Testing
In this terminal session, I've started the server in the background and then used the client to execute some commands:
```
$ ./is_shell_sv &
[1] 75236
$ Shell server listening on port 50000

$ ./is_shell_cl 127.0.0.1 'echo "hello world"'
hello world
$ ./is_shell_cl 127.0.0.1 'ls -la | head -5'
total 676
drwxr-xr-x 28 debian debian    896 Oct  4 01:25 .
drwxr-xr-x 65 debian dialout  2080 Oct  2 22:37 ..
-rw-r--r--  1 debian debian   1357 Oct  3 14:08 01.md
-rw-r--r--  1 debian debian   2052 Oct  3 23:56 02.md
$ ./is_shell_cl 127.0.0.1 'date'
Sat Oct  4 01:30:04 AM IDT 2025
$ ./is_shell_cl 127.0.0.1 'ps aux | grep bash'
debian     75473  0.0  0.0   2200   760 pts/2    S+   01:32   0:00 ./is_shell_cl 127.0.0.1 ps aux | grep bash
debian     75474  0.0  0.0   2320   820 pts/2    SN   01:32   0:00 sh -c ps aux | grep bash
debian     75476  0.0  0.0   6092  1948 pts/2    SN   01:32   0:00 grep bash
$
```
