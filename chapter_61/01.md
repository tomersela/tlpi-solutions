If the client runs in a single process that first writes all of stdin to the socket and only then starts reading, a deadlock can occur when the input is large.

Here’s why:
- The server reads data from the client and immediately echoes it back.
- Since the client is not yet reading, the echoed data accumulates in the client’s TCP receive buffer.
- Once that buffer is full, the client’s TCP stack advertises a zero window (no space available).
- The server’s next write() blocks, and because it’s stuck in write(), it can’t go back to read() more client input.
- On the other side, the client is still trying to write() stdin. But since the server has stopped reading, the server’s receive buffer fills, and the client’s write() blocks as well.

At this point, both sides are waiting on each other—classic deadlock.

### Further note
Deadlock can be avoided in a single-process client if it interleaves input and output. For example, by reading a small chunk from stdin, writing it to the socket, and then immediately reading and displaying the server’s reply. This prevents the client’s receive buffer from filling and blocking the server’s writes. Alternatively, if the server buffered all client input before echoing, the naïve “write-then-read” approach could also work, though this is not typical of simple echo servers.
