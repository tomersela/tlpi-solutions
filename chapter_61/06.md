# Design
The client creates an ephemeral listening socket and connects to the server normally. It sends a cookie and its listening port to the server. The server then connects back to establish the priority channel and returns the cookie for verification.

File transfers work by sending a SIZE message first, then streaming the exact number of bytes. This avoids protocol ambiguity if files contain control messages.

Server uses select() to handle both sockets. Client downloads one file at a time and can be interrupted with Ctrl+C.

## protocol
Our protocol is text-based with newline-terminated commands. Normal socket handles connection setup and file data, priority socket handles verification and interruption commands.

The flow works like this: the client calls the server and says "I'm listening on port X, here's my secret cookie". The server then calls the client back on that port to establish the priority channel. To prove it's really the server, it sends back the same cookie. Once verified, the client can request files and the server streams them over the normal connection. If the client wants to cancel mid-transfer, it sends a reset command over the priority channel.

Connection setup:
1. Client -> Server: `CONNECT:cookie:port\n` (normal socket)
2. Server connects back to client's port (priority socket)
3. Server -> Client: `COOKIE:cookie\n` (priority socket)
4. Client -> Server: `VERIFIED\n` (priority socket)

File transfer:
1. Client -> Server: `TRANSFER:filename\n` (normal socket)
2. Server -> Client: `SIZE:bytes\n` (normal socket)
3. Server -> Client: binary file data (normal socket)

Priority commands (during transfer):
- Client -> Server: `RESET\n` (priority socket) - cancel transfer
- Client -> Server: `STATUS\n` (priority socket) - get status

## Gaps from a real world protocol
This educational implementation has several gaps compared to production file transfer protocols:

**Authentication** - Real servers use proper authentication (certificates, OAuth, etc.) instead of simple cookies.

**Encryption** - Production systems encrypt all data in transit. Our protocol sends everything in plaintext.

**Multiple clients** - Real servers handle thousands of concurrent connections, not just one at a time.

**Resume capability** - Production protocols support resuming interrupted transfers from the last checkpoint.

**Bandwidth control** - Real systems implement rate limiting and QoS to manage network resources.

**Error recovery** - Production protocols have sophisticated retry logic and corruption detection.

**Firewall traversal** - The book's suggestion of having the server connect back to the client won't work in practice because firewalls and NAT typically only allow outbound connections from clients. Real systems work around this by having clients maintain both connections or using proxy servers.


# Implementation
The code is split into shared protocol definitions (`pftp.h`), common utilities (`pftp_common.c`), server (`pftp_server.c`), and client (`pftp_client.c`). Both programs use single-threaded event loops with select() for I/O multiplexing.

The server maintains global state for one client connection and can serve files from a `files/` directory. The client is designed as a simple downloader that fetches one file per invocation.

Security is handled through cookie verification and filename validation that prevents directory traversal attacks.

## pftp.h
Shared header defining the protocol constants, command strings, error messages, and function prototypes used by both client and server. It contains file system constants, and all the text-based protocol commands.

The error messages are pre-formatted with newlines to simplify sending, and the command prefixes allow easy parsing with `strncmp()`. Function prototypes include filename validation, cookie generation, and command parsing utilities.

We chose a buffer size of 8KB, this isn't optimized for speed, it's tuned to be relatively fast, but not too fast so we can test the cancelation logic (this is what we're here for, aren't we?)

```C
#ifndef PFTP_H
#define PFTP_H

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>
#include <dirent.h>
#include <sys/stat.h>
#include "tlpi_hdr.h"

// protocol constants
#define BUFFER_SIZE 8192   // 8KB - good balance of speed vs interruptible
#define PROGRESS_INTERVAL 10240  // show progress every 10KB
#define FILES_DIR "files"
#define MAX_FILENAME_LEN 255
#define MAX_COOKIE_LEN 63

// protocol command strings
#define CMD_CONNECT "CONNECT:"
#define CMD_TRANSFER "TRANSFER:"
#define CMD_COOKIE "COOKIE:"
#define CMD_RESET "RESET"
#define CMD_STATUS "STATUS"
#define CMD_VERIFIED "VERIFIED"

// protocol response strings
#define RESP_OK "OK"
#define RESP_ERROR "ERROR:"
#define RESP_SIZE "SIZE:"
#define RESP_COMPLETE "COMPLETE"
#define RESP_STATUS "STATUS:"
#define RESP_RESET "RESET:"

// error messages
#define ERR_INVALID_CONNECT "ERROR:Invalid CONNECT format\n"
#define ERR_INVALID_PORT "ERROR:Invalid port number\n"
#define ERR_CANNOT_CREATE_PRIORITY "ERROR:Cannot create priority socket\n"
#define ERR_INVALID_CLIENT_IP "ERROR:Invalid client IP\n"
#define ERR_CANNOT_ESTABLISH_PRIORITY "ERROR:Cannot establish priority connection\n"
#define ERR_CANNOT_SEND_COOKIE "ERROR:Cannot send verification cookie\n"
#define ERR_UNKNOWN_COMMAND "ERROR:Unknown command\n"
#define ERR_PRIORITY_NOT_ESTABLISHED "ERROR:Priority connection not established\n"
#define ERR_TRANSFER_IN_PROGRESS "ERROR:Transfer already in progress\n"
#define ERR_INVALID_FILENAME "ERROR:Invalid filename\n"
#define ERR_FILE_NOT_FOUND "ERROR:File not found\n"
#define ERR_CANNOT_DETERMINE_SIZE "ERROR:Cannot determine file size\n"
#define ERR_FILE_READ_ERROR "ERROR:File read error\n"
#define ERR_UNKNOWN_PRIORITY_CMD "ERROR:Unknown priority command\n"

// response messages
#define MSG_OK "OK\n"
#define MSG_COMPLETE "COMPLETE\n"
#define MSG_STATUS_IDLE "STATUS:Idle\n"
#define MSG_STATUS_NO_TRANSFER "STATUS:No transfer in progress\n"
#define MSG_RESET_CANCELLED "RESET:Transfer cancelled\n"
#define MSG_RESET_OK "OK:Transfer reset\n"

// shared function prototypes
int validate_filename(const char *filename);
void generate_cookie(char *cookie, size_t cookie_size);
int parse_connect_command(const char *message, char *cookie, char *port_str);

#endif // PFTP_H

```

## pftp_server.c
Single-client server that uses global state to track one connection at a time. The main loop uses select() with adaptive timeouts - non-blocking when transferring files for maximum speed, infinite timeout when idle to save CPU.

The server handles three types of events: new client connections on the listening socket, commands and data on the normal socket, and priority commands on the priority socket. File transfers stream data continuously without waiting for client acknowledgments.

`handle_connect_command()` establishes the reverse priority connection, `handle_transfer_command()` validates filenames and starts transfers, `continue_file_transfer()` streams file data in chunks.

```C
#include <signal.h>
#include "pftp.h"

// simple global state for single client
static int server_fd = -1;
static int normal_fd = -1;
static int priority_fd = -1;
static char cookie[MAX_COOKIE_LEN + 1];
static FILE *transfer_file = NULL;

static void cleanup_and_exit(int sig);
static void setup_server(int port);
static void handle_new_connection(void);
static void handle_normal_data(void);
static void handle_priority_data(void);
static void continue_file_transfer(void);
static void handle_connect_command(const char *buffer);
static void handle_transfer_command(const char *filename);

int
main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "usage: %s port\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    signal(SIGINT, cleanup_and_exit);
    mkdir(FILES_DIR, 0755);
    setup_server(atoi(argv[1]));

    // main loop
    for (;;) {
        fd_set readfds;
        FD_ZERO(&readfds);
        FD_SET(server_fd, &readfds);

        int maxfd = server_fd;
        if (normal_fd != -1) { FD_SET(normal_fd, &readfds); maxfd = normal_fd; }
        if (priority_fd != -1) { FD_SET(priority_fd, &readfds); if (priority_fd > maxfd) maxfd = priority_fd; }

        // no timeout when transferring - go full speed
        struct timeval timeout = {0, 0}, *timeout_ptr = NULL;
        if (transfer_file) timeout_ptr = &timeout;

        int ready = select(maxfd + 1, &readfds, NULL, NULL, timeout_ptr);
        if (ready == -1 && errno != EINTR) break;

        if (ready == 0 && transfer_file) {
            continue_file_transfer();
            continue;
        }

        if (FD_ISSET(server_fd, &readfds)) handle_new_connection();
        if (normal_fd != -1 && FD_ISSET(normal_fd, &readfds)) handle_normal_data();
        if (priority_fd != -1 && FD_ISSET(priority_fd, &readfds)) handle_priority_data();
    }

    cleanup_and_exit(0);
    return 0;
}

static void
setup_server(int port)
{
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    int optval = 1;
    setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));

    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(port);

    bind(server_fd, (struct sockaddr *) &addr, sizeof(addr));
    listen(server_fd, 1);

    printf("[server] pftp server listening on port %d\n", port);
}

static void
handle_new_connection(void)
{
    if (normal_fd == -1) {
        normal_fd = accept(server_fd, NULL, NULL);
        printf("[server] client connected\n");
    } else {
        int fd = accept(server_fd, NULL, NULL);
        close(fd); // reject - already have client
    }
}

static void
handle_normal_data(void)
{
    char buffer[BUFFER_SIZE];
    ssize_t bytes = recv(normal_fd, buffer, sizeof(buffer) - 1, 0);
    if (bytes <= 0) {
        close(normal_fd); normal_fd = -1;
        if (priority_fd != -1) { close(priority_fd); priority_fd = -1; }
        if (transfer_file) { fclose(transfer_file); transfer_file = NULL; }
        printf("[server] client disconnected\n");
        return;
    }

    buffer[bytes] = '\0';
    if (buffer[bytes-1] == '\n') buffer[bytes-1] = '\0';

    if (strncmp(buffer, CMD_CONNECT, strlen(CMD_CONNECT)) == 0) {
        handle_connect_command(buffer);
    } else if (strncmp(buffer, CMD_TRANSFER, strlen(CMD_TRANSFER)) == 0) {
        const char *filename = buffer + strlen(CMD_TRANSFER);
        handle_transfer_command(filename);
    }
}

static void
handle_connect_command(const char *buffer)
{
    char recv_cookie[64], port_str[16];
    if (!parse_connect_command(buffer, recv_cookie, port_str)) return;

    strcpy(cookie, recv_cookie);
    int client_port = atoi(port_str);

    // get client IP and connect back
    struct sockaddr_in client_addr;
    socklen_t len = sizeof(client_addr);
    getpeername(normal_fd, (struct sockaddr*)&client_addr, &len);
    client_addr.sin_port = htons(client_port);

    priority_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (connect(priority_fd, (struct sockaddr*)&client_addr, sizeof(client_addr)) == 0) {
        char msg[128];
        snprintf(msg, sizeof(msg), "%s%s\n", CMD_COOKIE, cookie);
        send(priority_fd, msg, strlen(msg), 0);
        send(normal_fd, MSG_OK, strlen(MSG_OK), 0);
        printf("[server] priority connection established\n");
    } else {
        close(priority_fd); priority_fd = -1;
        send(normal_fd, ERR_CANNOT_ESTABLISH_PRIORITY, strlen(ERR_CANNOT_ESTABLISH_PRIORITY), 0);
    }
}

static void
handle_transfer_command(const char *filename)
{
    if (!validate_filename(filename)) {
        send(normal_fd, ERR_INVALID_FILENAME, strlen(ERR_INVALID_FILENAME), 0);
        return;
    }

    char filepath[512];
    snprintf(filepath, sizeof(filepath), "%s/%s", FILES_DIR, filename);
    transfer_file = fopen(filepath, "rb");
    if (!transfer_file) {
        send(normal_fd, ERR_FILE_NOT_FOUND, strlen(ERR_FILE_NOT_FOUND), 0);
        return;
    }

    struct stat st;
    if (stat(filepath, &st) == 0) {
        char msg[128];
        snprintf(msg, sizeof(msg), "%s%ld\n", RESP_SIZE, st.st_size);
        send(normal_fd, msg, strlen(msg), 0);
        printf("[server] starting transfer: %s (%ld bytes)\n", filename, st.st_size);
    } else {
        fclose(transfer_file);
        transfer_file = NULL;
        send(normal_fd, ERR_CANNOT_DETERMINE_SIZE, strlen(ERR_CANNOT_DETERMINE_SIZE), 0);
    }
}

static void
continue_file_transfer(void)
{
    char buffer[BUFFER_SIZE];
    size_t bytes = fread(buffer, 1, sizeof(buffer), transfer_file);
    if (bytes == 0) {
        // end of file - just close, no message needed
        fclose(transfer_file);
        transfer_file = NULL;
        printf("[server] transfer completed\n");
    } else {
        send(normal_fd, buffer, bytes, 0);
    }
}

static void
handle_priority_data(void)
{
    char buffer[BUFFER_SIZE];
    ssize_t bytes = recv(priority_fd, buffer, sizeof(buffer) - 1, 0);
    if (bytes <= 0) {
        close(priority_fd); priority_fd = -1;
        return;
    }

    buffer[bytes] = '\0';
    if (buffer[bytes-1] == '\n') buffer[bytes-1] = '\0';

    if (strcmp(buffer, CMD_VERIFIED) == 0) {
        printf("[server] priority connection verified\n");
    } else if (strcmp(buffer, CMD_RESET) == 0) {
        if (transfer_file) {
            fclose(transfer_file);
            transfer_file = NULL;
            send(normal_fd, MSG_RESET_CANCELLED, strlen(MSG_RESET_CANCELLED), 0);
            send(priority_fd, MSG_RESET_OK, strlen(MSG_RESET_OK), 0);
            printf("[server] transfer reset\n");
        }
    }
}

static void
cleanup_and_exit(int sig)
{
    if (transfer_file) fclose(transfer_file);
    if (normal_fd != -1) close(normal_fd);
    if (priority_fd != -1) close(priority_fd);
    if (server_fd != -1) close(server_fd);
    exit(0);
}

```

## pftp_client.c
Simple file downloader that establishes dual-socket connection and downloads one file per invocation. The client uses global state to track both socket connections and file transfer progress. The main loop uses select() to handle incoming data on both sockets, with automatic progress reporting and Ctrl+C interruption support.

`setup_connection()` creates ephemeral listening socket and connects to server, `handle_server_data()` processes file data and completion, `handle_priority_data()` verifies cookies and handles server responses.

```C
#include <signal.h>
#include <netdb.h>
#include "pftp.h"

// simple global state
static int normal_fd = -1;
static int priority_fd = -1;
static int listening_fd = -1;
static char cookie[MAX_COOKIE_LEN + 1];
static char filename[MAX_FILENAME_LEN + 1];
static FILE *output_file = NULL;
static long file_size = 0;
static long bytes_received = 0;

static void cleanup_and_exit(int sig);
static void setup_listening_socket(void);
static void connect_to_server(const char *host, int port);
static void send_connect_command(void);
static void accept_priority_connection(void);
static void verify_cookie(void);
static void request_file_transfer(void);
static void handle_server_data(void);
static void handle_priority_data(void);
static void print_progress(void);

int
main(int argc, char *argv[])
{
    if (argc != 4) {
        printf("usage: %s <server_host> <server_port> <filename>\n", argv[0]);
        printf("example: %s localhost 8080 medium.dat\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    signal(SIGINT, cleanup_and_exit);

    strncpy(filename, argv[3], sizeof(filename) - 1);
    if (!validate_filename(filename)) {
        fprintf(stderr, "invalid filename: %s\n", filename);
        exit(EXIT_FAILURE);
    }

    printf("[client] pftp client - downloading %s from %s:%s\n", filename, argv[1], argv[2]);

    // establish connections
    setup_listening_socket();
    connect_to_server(argv[1], atoi(argv[2]));
    send_connect_command();
    accept_priority_connection();
    verify_cookie();

    printf("[client] connected! starting file transfer...\n");
    request_file_transfer();

    // simple event loop - wait for file transfer to complete
    int transfer_active = 1;
    while (transfer_active) {
        fd_set readfds;
        FD_ZERO(&readfds);
        FD_SET(normal_fd, &readfds);
        FD_SET(priority_fd, &readfds);

        int maxfd = (normal_fd > priority_fd) ? normal_fd : priority_fd;
        struct timeval timeout = {1, 0}; // 1 second for progress updates

        int ready = select(maxfd + 1, &readfds, NULL, NULL, &timeout);
        if (ready == -1 && errno != EINTR) break;

        if (ready == 0) {
            print_progress();
            continue;
        }

        if (FD_ISSET(normal_fd, &readfds)) {
            handle_server_data();
            // check if transfer completed
            if (output_file == NULL) {
                transfer_active = 0;
            }
        }
        if (FD_ISSET(priority_fd, &readfds)) handle_priority_data();
    }

    printf("[client] transfer completed successfully!\n");
    cleanup_and_exit(0);
    return 0;
}

static void
setup_listening_socket(void)
{
    listening_fd = socket(AF_INET, SOCK_STREAM, 0);
    int optval = 1;
    setsockopt(listening_fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));

    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = INADDR_ANY;
    addr.sin_port = htons(0); // ephemeral port

    bind(listening_fd, (struct sockaddr *) &addr, sizeof(addr));
    listen(listening_fd, 1);

    // get assigned port
    socklen_t len = sizeof(addr);
    getsockname(listening_fd, (struct sockaddr *) &addr, &len);
    printf("[client] listening on ephemeral port %d\n", ntohs(addr.sin_port));
}

static void
connect_to_server(const char *host, int port)
{
    normal_fd = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in addr = {0};
    addr.sin_family = AF_INET;
    addr.sin_port = htons(port);

    // try IP address first, then hostname
    if (inet_pton(AF_INET, host, &addr.sin_addr) != 1) {
        struct hostent *he = gethostbyname(host);
        if (!he) {
            fprintf(stderr, "hostname resolution failed: %s\n", host);
            exit(EXIT_FAILURE);
        }
        memcpy(&addr.sin_addr, he->h_addr_list[0], he->h_length);
    }

    if (connect(normal_fd, (struct sockaddr *) &addr, sizeof(addr)) == -1) {
        perror("connect");
        exit(EXIT_FAILURE);
    }

    printf("[client] connected to server %s:%d\n", host, port);
}

static void
send_connect_command(void)
{
    // get listening port
    struct sockaddr_in addr;
    socklen_t len = sizeof(addr);
    getsockname(listening_fd, (struct sockaddr *) &addr, &len);
    int listening_port = ntohs(addr.sin_port);

    // generate cookie
    generate_cookie(cookie, sizeof(cookie));

    // send CONNECT command
    char msg[256];
    snprintf(msg, sizeof(msg), "%s%s:%d\n", CMD_CONNECT, cookie, listening_port);
    send(normal_fd, msg, strlen(msg), 0);

    // wait for OK
    char response[BUFFER_SIZE];
    recv(normal_fd, response, sizeof(response) - 1, 0);
    if (strncmp(response, RESP_OK, strlen(RESP_OK)) != 0) {
        fprintf(stderr, "server error: %s", response);
        exit(EXIT_FAILURE);
    }

    printf("[client] connect command accepted\n");
}

static void
accept_priority_connection(void)
{
    printf("[client] waiting for server priority connection...\n");
    priority_fd = accept(listening_fd, NULL, NULL);
    if (priority_fd == -1) {
        perror("accept priority");
        exit(EXIT_FAILURE);
    }
    printf("[client] priority connection established\n");
}

static void
verify_cookie(void)
{
    char buffer[BUFFER_SIZE];
    recv(priority_fd, buffer, sizeof(buffer) - 1, 0);

    // parse "COOKIE:xxx"
    char received_cookie[MAX_COOKIE_LEN + 1];
    if (sscanf(buffer, "%*[^:]:%63s", received_cookie) != 1 ||
        strcmp(received_cookie, cookie) != 0) {
        fprintf(stderr, "cookie verification failed\n");
        exit(EXIT_FAILURE);
    }

    // send verification
    send(priority_fd, CMD_VERIFIED "\n", strlen(CMD_VERIFIED "\n"), 0);
    printf("[client] cookie verified\n");
}

static void
request_file_transfer(void)
{
    char msg[512];
    snprintf(msg, sizeof(msg), "%s%s\n", CMD_TRANSFER, filename);
    send(normal_fd, msg, strlen(msg), 0);
    printf("[client] requesting file: %s\n", filename);
}

static void
handle_server_data(void)
{
    char buffer[BUFFER_SIZE];
    ssize_t bytes = recv(normal_fd, buffer, sizeof(buffer), 0);
    if (bytes <= 0) {
        if (bytes == 0) {
            printf("[client] server disconnected\n");
        } else {
            perror("[client] recv server data");
        }
        cleanup_and_exit(1);
    }

    if (output_file == NULL) {
        // first response - should be SIZE: or ERROR:
        buffer[bytes] = '\0';

        if (strncmp(buffer, RESP_SIZE, strlen(RESP_SIZE)) == 0) {
            file_size = atol(buffer + strlen(RESP_SIZE));
            printf("[client] file size: %ld bytes\n", file_size);

            output_file = fopen(filename, "wb");
            if (!output_file) {
                perror("fopen output file");
                cleanup_and_exit(1);
            }
            return;
        } else if (strncmp(buffer, RESP_ERROR, strlen(RESP_ERROR)) == 0) {
            printf("[client] server error: %s", buffer);
            cleanup_and_exit(1);
        } else if (strncmp(buffer, MSG_COMPLETE, strlen(MSG_COMPLETE)) == 0) {
            printf("[client] transfer completed (empty file)\n");
            cleanup_and_exit(0);
        }
        return; // ignore other messages while waiting for SIZE
    }

    // file data - write to file
    fwrite(buffer, 1, bytes, output_file);
    bytes_received += bytes;

    // check completion by size (exact byte count)
    if (bytes_received >= file_size) {
        fclose(output_file);
        output_file = NULL;
        printf("[client] file received: %ld bytes\n", bytes_received);
    }
}

static void
handle_priority_data(void)
{
    char buffer[BUFFER_SIZE];
    ssize_t bytes = recv(priority_fd, buffer, sizeof(buffer) - 1, 0);
    if (bytes > 0) {
        buffer[bytes] = '\0';
        printf("priority: %s", buffer);
    }
}

static void
print_progress(void)
{
    if (output_file && file_size > 0) {
        double percent = (double)bytes_received * 100.0 / file_size;
        printf("\r[client] progress: %ld/%ld bytes (%.1f%%)  ", bytes_received, file_size, percent);
        fflush(stdout);
    }
}

static void
cleanup_and_exit(int sig)
{
    if (sig == SIGINT && output_file) {
        printf("\n[client] interrupted! sending reset...\n");
        if (priority_fd != -1) {
            send(priority_fd, CMD_RESET "\n", strlen(CMD_RESET "\n"), 0);
            usleep(100000);
        }
    }

    if (output_file) fclose(output_file);
    if (normal_fd != -1) close(normal_fd);
    if (priority_fd != -1) close(priority_fd);
    if (listening_fd != -1) close(listening_fd);

    exit(sig == SIGINT ? 0 : sig);
}

```

# Testing

## Preperation
As a preparation for testing, I two files in the "files" folder:
```
$ echo "Hello World" > files/small.txt
$ dd if=/dev/zero of=files/big.dat bs=1024 count=51200 # 50MB file
$
```

Then starting the server:
```
$ $ ./pftp_server 8080 &
[1] 80126
$ [server] pftp server listening on port 8080

$
```

## Fetching a small file
```
$ ./pftp_client localhost 8080 small.txt
[client] pftp client - downloading small.txt from localhost:8080
[client] listening on ephemeral port 45957
[client] connected to server localhost:8080
[server] client connected
[server] priority connection established
[client] connect command accepted
[client] waiting for server priority connection...
[client] priority connection established
[client] cookie verified
[server] priority connection verified
[client] connected! starting file transfer...
[client] requesting file: small.txt
[server] starting transfer: small.txt (12 bytes)
[client] file size: 12 bytes
[server] transfer completed
[client] file received: 12 bytes
[client] transfer completed successfully!
[server] client disconnected
$ cat files/small.txt
Hello World
$
```

## Fetching a bigger file
```
$ ./pftp_client localhost 8080 big.dat
[client] pftp client - downloading big.dat from localhost:8080
[client] listening on ephemeral port 37179
[client] connected to server localhost:8080
[server] client connected
[server] priority connection established
[client] connect command accepted
[client] waiting for server priority connection...
[client] priority connection established
[client] cookie verified
[client] connected! starting file transfer...
[client] requesting file: big.dat
[server] starting transfer: big.dat (52428800 bytes)
[server] priority connection verified
[client] file size: 52428800 bytes
[server] transfer completed
[client] file received: 52428800 bytes
[client] transfer completed successfully!
[server] client disconnected
$ ls -l ./big.dat
-rw-r--r-- 1 debian debian 52428800 Oct  4 11:23 ./big.dat
$
```

## Cancellation mid transfer
```
$ ./pftp_client localhost 8080 big.dat
[client] pftp client - downloading big.dat from localhost:8080
[client] listening on ephemeral port 38465
[client] connected to server localhost:8080
[server] client connected
[server] priority connection established
[client] connect command accepted
[client] waiting for server priority connection...
[client] priority connection established
[client] cookie verified
[server] priority connection verified
[client] connected! starting file transfer...
[client] requesting file: big.dat
[server] starting transfer: big.dat (52428800 bytes)
[client] file size: 52428800 bytes
^C
[client] interrupted! sending reset...
[server] client disconnected
$ ls -l ./big.dat
-rw-r--r-- 1 debian debian 23093248 Oct  4 11:23 ./big.dat
$
```

## File not found (handled error)
```
$ ./pftp_client localhost 8080 huge.dat
[client] pftp client - downloading huge.dat from localhost:8080
[client] listening on ephemeral port 41127
[client] connected to server localhost:8080
[server] client connected
[server] priority connection established
[client] connect command accepted
[client] waiting for server priority connection...
[client] priority connection established
[client] cookie verified
[client] connected! starting file transfer...
[client] requesting file: huge.dat
[server] priority connection verified
[client] server error: ERROR:File not found
[server] client disconnected
$
```

## cleanup
```
$ rm small.txt
$ rm big.dat
$ rm files/small.txt
$ rm files/big.dat
$
```