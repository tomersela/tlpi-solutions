# Code

## posix_sem.h
```C
/*************************************************************************\
*                  POSIX Semaphore Implementation Header                 *
*                  using System V semaphores                            *
\*************************************************************************/

#ifndef POSIX_SEM_H
#define POSIX_SEM_H

#include <time.h>

/* POSIX semaphore type - opaque to users */
typedef void sem_t;

/* POSIX semaphore constants */
#define SEM_FAILED ((sem_t *) -1)  /* Error return value */


/* Function declarations for POSIX semaphore API */
sem_t *sem_open(const char *name, int oflag, ...);
int sem_wait(sem_t *sem);
int sem_trywait(sem_t *sem);
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
int sem_post(sem_t *sem);
int sem_close(sem_t *sem);
int sem_unlink(const char *name);
int sem_getvalue(sem_t *sem, int *sval);

#endif /* POSIX_SEM_H */

```

## posix_sem.c
```C
/* posix_sem.c

  Solution for Exercise 53.3
  
  Implementation of POSIX semaphores using System V semaphores.
  
  This implementation provides the POSIX semaphore API on top of System V
  semaphore primitives. Named semaphores are managed using a combination
  of a System V semaphore for the actual counting and a shared memory
  segment for metadata.
*/

#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <fcntl.h>
#include <time.h>
#include <limits.h>
#include <stdarg.h>
#include <signal.h>

#include "tlpi_hdr.h"
#include "semun.h"      // system V semaphore union definition
#include "posix_sem.h"  // our POSIX semaphore API header


/* Internal structure to represent a POSIX semaphore */
struct posix_sem {
    int semid;          // system V semaphore ID
    int shmid;          // shared memory ID for metadata
    char *name;         // semaphore name (for unlink)
    int ref_count;      // reference count for this process
};

/* Metadata stored in shared memory */
struct sem_metadata {
    int initialized;     // magic number to verify initialization
    int unlinked;        // set to 1 if sem_unlink() was called
    int ref_count;       // total reference count across all processes
    mode_t mode;         // permission bits
    char name[NAME_MAX]; // semaphore name
};

#define SEM_MAGIC 0x53454D00  // magic number for initialized semaphores
#define SEM_FAILED_INTERNAL ((struct posix_sem *) -1)

/* Dummy signal handler for SIGALRM - does nothing but allows signal to interrupt system calls */
static void
dummy_alarm_handler(int sig)
{
    // Do nothing - we just need the signal to interrupt semop()
    (void) sig;  // Suppress unused parameter warning
}


/* Generate System V IPC key from semaphore name */
static key_t
name_to_key(const char *name)
{
    key_t key;
    char pathname[256];
    int fd;
    
    // create a pathname based on the semaphore name
    // we'll use /tmp as the base directory and the semaphore name as filename
    snprintf(pathname, sizeof(pathname), "/tmp/posix_sem_%s", name);
    
    // ensure the file exists for ftok() - create it if it doesn't exist
    fd = open(pathname, O_CREAT | O_EXCL, 0644);
    if (fd != -1) {
        close(fd);
    } else if (errno != EEXIST) {
        // if we can't create the file and it's not because it exists,
        // fall back to using a well-known existing file
        strcpy(pathname, "/tmp");
    }
    
    // use ftok() to generate the key - this is the standard System V way
    // we use project ID based on first char of name for some uniqueness
    key = ftok(pathname, name[0] ? name[0] : 'P');
    
    return key;
}


sem_t *
sem_open(const char *name, int oflag, ...)
{
    struct posix_sem *sem;
    key_t key;
    int semid, shmid;
    struct sem_metadata *metadata;
    union semun arg;
    mode_t mode = S_IRUSR | S_IWUSR;
    unsigned int value = 0;
    va_list ap;
    
    if (name == NULL || name[0] != '/') {
        errno = EINVAL;
        return SEM_FAILED;
    }
    
    // skip leading slash and check name length
    name++;
    if (strlen(name) >= NAME_MAX) {
        errno = ENAMETOOLONG;
        return SEM_FAILED;
    }
    
    // get additional arguments if O_CREAT is specified
    if (oflag & O_CREAT) {
        va_start(ap, oflag);
        mode = (mode_t) va_arg(ap, int);
        value = va_arg(ap, unsigned int);
        va_end(ap);
        
        if (value > SEM_VALUE_MAX) {
            errno = EINVAL;
            return SEM_FAILED;
        }
    }
    
    // generate key from name
    key = name_to_key(name);
    
    // allocate semaphore structure
    sem = malloc(sizeof(struct posix_sem));
    if (sem == NULL) {
        errno = ENOMEM;
        return SEM_FAILED;
    }
    
    // try to get existing semaphore first
    semid = semget(key, 1, 0);
    shmid = shmget(key, sizeof(struct sem_metadata), 0);
    
    if (semid == -1 || shmid == -1) {
        // semaphore doesn't exist
        if (!(oflag & O_CREAT)) {
            free(sem);
            errno = ENOENT;
            return SEM_FAILED;
        }
        
        // create new semaphore
        semid = semget(key, 1, IPC_CREAT | IPC_EXCL | (mode & 0777));
        if (semid == -1) {
            if (errno == EEXIST) {
                // race condition: another process created it
                if (oflag & O_EXCL) {
                    free(sem);
                    errno = EEXIST;
                    return SEM_FAILED;
                }
                // try to get the existing one
                semid = semget(key, 1, 0);
                shmid = shmget(key, sizeof(struct sem_metadata), 0);
                if (semid == -1 || shmid == -1) {
                    free(sem);
                    return SEM_FAILED;
                }
                goto existing_sem;
            }
            free(sem);
            return SEM_FAILED;
        }
        
        // create shared memory for metadata
        shmid = shmget(key, sizeof(struct sem_metadata), 
                       IPC_CREAT | IPC_EXCL | (mode & 0777));
        if (shmid == -1) {
            semctl(semid, 0, IPC_RMID);  // clean up semaphore
            free(sem);
            return SEM_FAILED;
        }
        
        // initialize semaphore value
        arg.val = value;
        if (semctl(semid, 0, SETVAL, arg) == -1) {
            semctl(semid, 0, IPC_RMID);
            shmctl(shmid, IPC_RMID, NULL);
            free(sem);
            return SEM_FAILED;
        }
        
        // initialize metadata
        metadata = shmat(shmid, NULL, 0);
        if (metadata == (void *) -1) {
            semctl(semid, 0, IPC_RMID);
            shmctl(shmid, IPC_RMID, NULL);
            free(sem);
            return SEM_FAILED;
        }
        
        metadata->initialized = SEM_MAGIC;
        metadata->unlinked = 0;
        metadata->ref_count = 1;
        metadata->mode = mode;
        strncpy(metadata->name, name, NAME_MAX - 1);
        metadata->name[NAME_MAX - 1] = '\0';
        
        shmdt(metadata);
        
    } else {
        // existing semaphore
        existing_sem:
        if (oflag & O_EXCL) {
            free(sem);
            errno = EEXIST;
            return SEM_FAILED;
        }
        
        // attach to metadata and verify
        metadata = shmat(shmid, NULL, 0);
        if (metadata == (void *) -1) {
            free(sem);
            return SEM_FAILED;
        }
        
        if (metadata->initialized != SEM_MAGIC) {
            shmdt(metadata);
            free(sem);
            errno = EINVAL;
            return SEM_FAILED;
        }
        
        if (metadata->unlinked) {
            shmdt(metadata);
            free(sem);
            errno = ENOENT;
            return SEM_FAILED;
        }
        
        // increment reference count
        metadata->ref_count++;
        shmdt(metadata);
    }
    
    // initialize our semaphore structure
    sem->semid = semid;
    sem->shmid = shmid;
    sem->name = strdup(name);
    sem->ref_count = 1;
    
    if (sem->name == NULL) {
        free(sem);
        errno = ENOMEM;
        return SEM_FAILED;
    }
    
    return (sem_t *) sem;
}


int
sem_wait(sem_t *sem_ptr)
{
    struct posix_sem *sem = (struct posix_sem *) sem_ptr;
    struct sembuf sop;
    
    if (sem == NULL || sem == SEM_FAILED_INTERNAL) {
        errno = EINVAL;
        return -1;
    }
    
    sop.sem_num = 0;
    sop.sem_op = -1;    // decrement
    sop.sem_flg = 0;    // block if necessary
    
    while (semop(sem->semid, &sop, 1) == -1) {
        if (errno != EINTR)
            return -1;
    }
    
    return 0;
}


int
sem_trywait(sem_t *sem_ptr)
{
    struct posix_sem *sem = (struct posix_sem *) sem_ptr;
    struct sembuf sop;
    
    if (sem == NULL || sem == SEM_FAILED_INTERNAL) {
        errno = EINVAL;
        return -1;
    }
    
    sop.sem_num = 0;
    sop.sem_op = -1;        // decrement
    sop.sem_flg = IPC_NOWAIT;  // don't block
    
    if (semop(sem->semid, &sop, 1) == -1) {
        if (errno == EAGAIN)
            errno = EAGAIN;  // POSIX expects EAGAIN for try operations
        return -1;
    }
    
    return 0;
}


int
sem_timedwait(sem_t *sem_ptr, const struct timespec *abs_timeout)
{
    struct posix_sem *sem = (struct posix_sem *) sem_ptr;
    struct timespec current_time;
    struct sembuf sop;
    
    if (sem == NULL || sem == SEM_FAILED_INTERNAL || abs_timeout == NULL) {
        errno = EINVAL;
        return -1;
    }
    
    if (abs_timeout->tv_nsec < 0 || abs_timeout->tv_nsec >= 1000000000) {
        errno = EINVAL;
        return -1;
    }
    
    // get current time
    if (clock_gettime(CLOCK_REALTIME, &current_time) == -1)
        return -1;
    
    // check if timeout has already passed
    if (current_time.tv_sec > abs_timeout->tv_sec ||
        (current_time.tv_sec == abs_timeout->tv_sec && 
         current_time.tv_nsec >= abs_timeout->tv_nsec)) {
        errno = ETIMEDOUT;
        return -1;
    }
    
    // try non-blocking first
    sop.sem_num = 0;
    sop.sem_op = -1;
    sop.sem_flg = IPC_NOWAIT;
    
    if (semop(sem->semid, &sop, 1) == 0)
        return 0;  // success
    
    if (errno != EAGAIN)
        return -1;  // real error
    
    // need to wait with timeout - System V semaphores don't support timeouts natively
    // we use a signal-based approach for better efficiency
    
    struct timespec remaining_time;
    remaining_time.tv_sec = abs_timeout->tv_sec - current_time.tv_sec;
    remaining_time.tv_nsec = abs_timeout->tv_nsec - current_time.tv_nsec;
    
    if (remaining_time.tv_nsec < 0) {
        remaining_time.tv_sec--;
        remaining_time.tv_nsec += 1000000000;
    }
    
    // set up alarm for timeout
    struct sigaction old_action, new_action;
    sigset_t old_mask, new_mask;
    
    // block SIGALRM initially
    sigemptyset(&new_mask);
    sigaddset(&new_mask, SIGALRM);
    sigprocmask(SIG_BLOCK, &new_mask, &old_mask);
    
    // set up dummy signal handler - we don't need to do anything in it
    // but we need a real handler (not SIG_IGN) for the signal to interrupt semop()
    new_action.sa_handler = dummy_alarm_handler;
    sigemptyset(&new_action.sa_mask);
    new_action.sa_flags = 0;
    
    if (sigaction(SIGALRM, &new_action, &old_action) == -1) {
        sigprocmask(SIG_SETMASK, &old_mask, NULL);
        return -1;
    }
    
    // set alarm
    alarm(remaining_time.tv_sec + (remaining_time.tv_nsec > 0 ? 1 : 0));
    
    // unblock SIGALRM so it can interrupt semop()
    sigprocmask(SIG_SETMASK, &old_mask, NULL);
    
    // try blocking semop - it will be interrupted by SIGALRM
    sop.sem_flg = 0;  // blocking operation
    int result = semop(sem->semid, &sop, 1);
    int saved_errno = errno;
    
    // clean up alarm and signal handler
    alarm(0);
    sigaction(SIGALRM, &old_action, NULL);
    // signal mask already restored above
    
    if (result == 0) {
        return 0;  // success
    }
    
    if (saved_errno == EINTR) {
        // interrupted by alarm - check if timeout expired
        if (clock_gettime(CLOCK_REALTIME, &current_time) == -1)
            return -1;
            
        if (current_time.tv_sec > abs_timeout->tv_sec ||
            (current_time.tv_sec == abs_timeout->tv_sec && 
             current_time.tv_nsec >= abs_timeout->tv_nsec)) {
            errno = ETIMEDOUT;
            return -1;
        }
        
        // interrupted but timeout not reached - try once more non-blocking
        sop.sem_flg = IPC_NOWAIT;
        if (semop(sem->semid, &sop, 1) == 0)
            return 0;
            
        if (errno == EAGAIN) {
            errno = ETIMEDOUT;  // close enough to timeout
        }
        return -1;
    }
    
    errno = saved_errno;
    return -1;
}

/* Implementation of sem_post() */
int
sem_post(sem_t *sem_ptr)
{
    struct posix_sem *sem = (struct posix_sem *) sem_ptr;
    struct sembuf sop;
    
    if (sem == NULL || sem == SEM_FAILED_INTERNAL) {
        errno = EINVAL;
        return -1;
    }
    
    sop.sem_num = 0;
    sop.sem_op = 1;     // increment
    sop.sem_flg = 0;
    
    return semop(sem->semid, &sop, 1);
}


int
sem_close(sem_t *sem_ptr)
{
    struct posix_sem *sem = (struct posix_sem *) sem_ptr;
    struct sem_metadata *metadata;
    
    if (sem == NULL || sem == SEM_FAILED_INTERNAL) {
        errno = EINVAL;
        return -1;
    }
    
    // decrement reference count in shared memory
    metadata = shmat(sem->shmid, NULL, 0);
    if (metadata != (void *) -1) {
        metadata->ref_count--;
        
        // if this was the last reference and semaphore was unlinked,
        // clean up resources
        if (metadata->ref_count == 0 && metadata->unlinked) {
            shmdt(metadata);
            semctl(sem->semid, 0, IPC_RMID);
            shmctl(sem->shmid, IPC_RMID, NULL);
        } else {
            shmdt(metadata);
        }
    }
    
    // free our local resources
    free(sem->name);
    free(sem);
    
    return 0;
}


int
sem_unlink(const char *name)
{
    key_t key;
    int semid, shmid;
    struct sem_metadata *metadata;
    
    if (name == NULL || name[0] != '/') {
        errno = EINVAL;
        return -1;
    }
    
    // skip leading slash
    name++;
    if (strlen(name) >= NAME_MAX) {
        errno = ENAMETOOLONG;
        return -1;
    }
    
    // generate key from name
    key = name_to_key(name);
    
    // try to get existing semaphore
    semid = semget(key, 1, 0);
    shmid = shmget(key, sizeof(struct sem_metadata), 0);
    
    if (semid == -1 || shmid == -1) {
        errno = ENOENT;
        return -1;
    }
    
    // mark as unlinked in metadata
    metadata = shmat(shmid, NULL, 0);
    if (metadata == (void *) -1)
        return -1;
        
    if (metadata->initialized != SEM_MAGIC) {
        shmdt(metadata);
        errno = ENOENT;
        return -1;
    }
    
    metadata->unlinked = 1;
    
    // if no processes have it open, clean up immediately
    if (metadata->ref_count == 0) {
        shmdt(metadata);
        semctl(semid, 0, IPC_RMID);
        shmctl(shmid, IPC_RMID, NULL);
    } else {
        shmdt(metadata);
    }
    
    return 0;
}


int
sem_getvalue(sem_t *sem_ptr, int *sval)
{
    struct posix_sem *sem = (struct posix_sem *) sem_ptr;
    
    if (sem == NULL || sem == SEM_FAILED_INTERNAL || sval == NULL) {
        errno = EINVAL;
        return -1;
    }
    
    *sval = semctl(sem->semid, 0, GETVAL);
    if (*sval == -1)
        return -1;
        
    return 0;
}

```

# Testing

## posix_sem_test.c
```C
#include <sys/wait.h>
#include <fcntl.h>

#include "tlpi_hdr.h"
#include "posix_sem.h"  /* Our POSIX semaphore implementation */

// Global variables for cleanup
static sem_t *global_sem = NULL;
static char global_sem_name[64] = {0};

// Helper function to reset semaphore to a specific value
static void reset_semaphore_value(sem_t *sem, int target_value) {
    int current_value;
    
    // get current value
    if (sem_getvalue(sem, &current_value) == -1) {
        perror("sem_getvalue in reset_semaphore_value");
        exit(EXIT_FAILURE);
    }
    
    // if current value is higher than target, drain the excess
    while (current_value > target_value) {
        if (sem_trywait(sem) == -1) {
            if (errno == EAGAIN) {
                break; // semaphore is already at 0
            }
            perror("sem_trywait in reset_semaphore_value");
            exit(EXIT_FAILURE);
        }
        current_value--;
    }
    
    // if current value is lower than target, post the difference
    while (current_value < target_value) {
        if (sem_post(sem) == -1) {
            perror("sem_post in reset_semaphore_value");
            exit(EXIT_FAILURE);
        }
        current_value++;
    }
}

// Cleanup function called by atexit()
static void cleanup_semaphore(void) {
    if (global_sem != NULL) {
        sem_close(global_sem);
        if (strlen(global_sem_name) > 0) {
            sem_unlink(global_sem_name);
        }
    }
}

int
main(int argc, char *argv[])
{
    sem_t *sem;
    pid_t pid;
    int status;
    char sem_name[64];
    
    // Use process ID and timestamp to create unique semaphore name
    snprintf(sem_name, sizeof(sem_name), "/test_sem_%d_%ld", getpid(), time(NULL));
    
    // Register cleanup function
    if (atexit(cleanup_semaphore) != 0) {
        fprintf(stderr, "Failed to register cleanup function\n");
        exit(EXIT_FAILURE);
    }
    
    printf("Testing POSIX semaphore implementation using System V semaphores\n");
    printf("================================================================\n\n");
    
    
    printf("Test 1: Creating semaphore '%s' with initial value 1\n", sem_name);
    
    sem = sem_open(sem_name, O_CREAT | O_EXCL, 0644, 1);
    if (sem == SEM_FAILED) {
        perror("sem_open");
        exit(EXIT_FAILURE);
    }
    
    // Set up global variables for cleanup
    global_sem = sem;
    strncpy(global_sem_name, sem_name, sizeof(global_sem_name) - 1);
    global_sem_name[sizeof(global_sem_name) - 1] = '\0';
    
    printf("SUCCESS: Semaphore created successfully\n\n");
    
    
    printf("Test 2: Checking semaphore value\n");
    reset_semaphore_value(sem, 1);
    
    int sval;
    if (sem_getvalue(sem, &sval) == -1) {
        perror("sem_getvalue");
        exit(EXIT_FAILURE);
    }
    printf("SUCCESS: Semaphore value: %d (expected: 1)\n\n", sval);
    
    
    printf("Test 3: Testing sem_wait() and sem_post()\n");
    reset_semaphore_value(sem, 1);
    
    if (sem_wait(sem) == -1) {
        perror("sem_wait");
        exit(EXIT_FAILURE);
    }
    printf("SUCCESS: sem_wait() succeeded\n");
    
    if (sem_getvalue(sem, &sval) == -1) {
        perror("sem_getvalue");
        exit(EXIT_FAILURE);
    }
    printf("SUCCESS: After sem_wait(), value: %d (expected: 0)\n", sval);
    
    if (sem_post(sem) == -1) {
        perror("sem_post");
        exit(EXIT_FAILURE);
    }
    printf("SUCCESS: sem_post() succeeded\n");
    
    if (sem_getvalue(sem, &sval) == -1) {
        perror("sem_getvalue");
        exit(EXIT_FAILURE);
    }
    printf("SUCCESS: After sem_post(), value: %d (expected: 1)\n\n", sval);
    
    
    printf("Test 4: Testing sem_trywait()\n");
    reset_semaphore_value(sem, 1);
    
    if (sem_trywait(sem) == -1) {
        perror("sem_trywait");
        exit(EXIT_FAILURE);
    }
    printf("SUCCESS: sem_trywait() succeeded when semaphore available\n");
    
    // Try again when not available
    if (sem_trywait(sem) == 0) {
        printf("FAILED: sem_trywait() should have failed when semaphore unavailable\n");
    } else if (errno == EAGAIN) {
        printf("SUCCESS: sem_trywait() correctly failed with EAGAIN when unavailable\n");
    } else {
        perror("sem_trywait unexpected error");
    }
    

    printf("\n");
    
    
    printf("Test 5: Testing with multiple processes\n");
    
    // Reset to known state (value = 0 for synchronization test)
    reset_semaphore_value(sem, 0);
    
    pid = fork();
    if (pid == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
    
    if (pid == 0) {
        // Child process
        sleep(1);  // Let parent get to sem_wait first
        printf("Child: Posting semaphore\n");
        if (sem_post(sem) == -1) {
            perror("child sem_post");
            _exit(EXIT_FAILURE);  // Use _exit() to bypass atexit() handlers
        }
        printf("Child: Posted semaphore successfully\n");
        _exit(EXIT_SUCCESS);  // Use _exit() to bypass atexit() handlers
    } else {
        // Parent process
        printf("Parent: Waiting on semaphore...\n");
        if (sem_wait(sem) == -1) {
            perror("parent sem_wait");
            exit(EXIT_FAILURE);
        }
        printf("Parent: Got semaphore from child\n");
        
        wait(&status);
        if (WEXITSTATUS(status) == 0) {
            printf("SUCCESS: Multi-process synchronization test passed\n");
        } else {
            printf("FAILED: Child process failed\n");
        }
    }
    printf("\n");
    
    
    printf("Test 6: Testing sem_timedwait()\n");
    
    // Reset to known state (value = 1)
    reset_semaphore_value(sem, 1);
    
    // Now make semaphore unavailable for timeout test
    if (sem_wait(sem) == -1) {
        perror("sem_wait for timedwait test");
        exit(EXIT_FAILURE);
    }
    
    // Test timeout case - should timeout after 2 seconds
    struct timespec timeout;
    if (clock_gettime(CLOCK_REALTIME, &timeout) == -1) {
        perror("clock_gettime");
        exit(EXIT_FAILURE);
    }
    timeout.tv_sec += 2;  // 2 second timeout
    time_t start_time = time(NULL);
    
    if (sem_timedwait(sem, &timeout) == -1) {
        time_t end_time = time(NULL);
        int elapsed = (int)(end_time - start_time);
        
        if (errno == ETIMEDOUT) {
            printf("SUCCESS: sem_timedwait() timed out after %d seconds\n", elapsed);
            if (elapsed >= 2 && elapsed <= 3) {
                printf("SUCCESS: Timeout occurred within expected time range\n");
            } else {
                printf("WARNING: Timeout took %d seconds (expected ~2)\n", elapsed);
            }
        } else {
            perror("sem_timedwait failed with unexpected error");
            exit(EXIT_FAILURE);
        }
    } else {
        printf("FAILED: sem_timedwait() should have timed out but succeeded\n");
        exit(EXIT_FAILURE);
    }
    
    // Test success case - make semaphore available and try again
    if (sem_post(sem) == -1) {
        perror("sem_post for timedwait test");
        exit(EXIT_FAILURE);
    }
    
    if (clock_gettime(CLOCK_REALTIME, &timeout) == -1) {
        perror("clock_gettime");
        exit(EXIT_FAILURE);
    }
    timeout.tv_sec += 2;  // 2 second timeout
    
    if (sem_timedwait(sem, &timeout) == -1) {
        perror("sem_timedwait should have succeeded");
        exit(EXIT_FAILURE);
    } else {
        printf("SUCCESS: sem_timedwait() succeeded when semaphore available\n");
    }
    
    // Restore semaphore to available state
    if (sem_post(sem) == -1) {
        perror("sem_post restore");
        exit(EXIT_FAILURE);
    }
    
    printf("\n");
    
    
    printf("Test 7: Testing sem_close() and sem_unlink()\n");
    if (sem_close(sem) == -1) {
        perror("sem_close");
        exit(EXIT_FAILURE);
    }
    printf("SUCCESS: sem_close() succeeded\n");
    
    if (sem_unlink(sem_name) == -1) {
        perror("sem_unlink");
        exit(EXIT_FAILURE);
    }
    printf("SUCCESS: sem_unlink() succeeded\n\n");
    
    // Clear global variables since we manually cleaned up
    global_sem = NULL;
    global_sem_name[0] = '\0';
    
    
    printf("Test 8: Verifying semaphore was unlinked\n");
    sem = sem_open(sem_name, 0);  /* Try to open without O_CREAT */
    if (sem == SEM_FAILED && errno == ENOENT) {
        printf("SUCCESS: Semaphore correctly unlinked\n");
    } else {
        printf("FAILED: Semaphore still exists after unlink\n");
        if (sem != SEM_FAILED) {
            sem_close(sem);
            sem_unlink(sem_name);
        }
    }
    
    
    printf("\n================================================================\n");
    printf("All tests completed!\n");
    
    return 0;
}

```

## Running
```
$ ./posix_sem_test
Testing POSIX semaphore implementation using System V semaphores
================================================================

Test 1: Creating semaphore '/test_sem_9215_1755982603' with initial value 1
SUCCESS: Semaphore created successfully

Test 2: Checking semaphore value
SUCCESS: Semaphore value: 1 (expected: 1)

Test 3: Testing sem_wait() and sem_post()
SUCCESS: sem_wait() succeeded
SUCCESS: After sem_wait(), value: 0 (expected: 0)
SUCCESS: sem_post() succeeded
SUCCESS: After sem_post(), value: 1 (expected: 1)

Test 4: Testing sem_trywait()
SUCCESS: sem_trywait() succeeded when semaphore available
SUCCESS: sem_trywait() correctly failed with EAGAIN when unavailable

Test 5: Testing with multiple processes
Parent: Waiting on semaphore...
Child: Posting semaphore
Child: Posted semaphore successfully
Parent: Got semaphore from child
SUCCESS: Multi-process synchronization test passed

Test 6: Testing sem_timedwait()
SUCCESS: sem_timedwait() timed out after 2 seconds
SUCCESS: Timeout occurred within expected time range
SUCCESS: sem_timedwait() succeeded when semaphore available

Test 7: Testing sem_close() and sem_unlink()
SUCCESS: sem_close() succeeded
SUCCESS: sem_unlink() succeeded

Test 8: Verifying semaphore was unlinked
SUCCESS: Semaphore correctly unlinked

================================================================
All tests completed!
```
