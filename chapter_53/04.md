# Comparing System V vs. POSIX Semaphores performance

This is what Section 53.5 specified regarding performance:
> In scenarios where there is a high degree of contention for a semaphore (i.e.,
> operations on the semaphore are frequently blocked because another process
> has set the semaphore to a value that prevents the operation proceeding imme-
> diately), then the performance of POSIX semaphores and System V sema-
> phores is similar. However, in cases where there is low contention for a
> semaphore (i.e., the semaphore’s value is such that operations can normally
> proceed without blocking), then POSIX semaphores perform considerably bet-
> ter than System V semaphores. (On the systems tested by the author, the differ-
> ence in performance is more than an order of magnitude; see Exercise 53-4.)
> POSIX semaphores perform so much better in this case because the way in
> which they are implemented only requires a system call when contention
> occurs, whereas System V semaphore operations always require a system call,
> regardless of contention.

# Code
The benchmark simulates uncontended access.There's only one process and the semaphore value oscillates between 0 and 1, never blocking.

## benchmark_posix_sem.c
POSIX semaphore benchmark program

```C
#include <sys/time.h>
#include <fcntl.h>
#include <semaphore.h>
#include <time.h>
#include "tlpi_hdr.h"

static void
usageError(const char *progName)
{
    fprintf(stderr, "Usage: %s num-operations\n", progName);
    fprintf(stderr, "  num-operations: number of increment/decrement cycles to perform\n");
    exit(EXIT_FAILURE);
}

int
main(int argc, char *argv[])
{
    if (argc != 2 || strcmp(argv[1], "--help") == 0)
        usageError(argv[0]);

    long numOps = getLong(argv[1], GN_GT_0, "num-operations");
    
    // create unique semaphore name
    char semName[64];
    snprintf(semName, sizeof(semName), "/posix_bench_%d_%ld", getpid(), (long) time(NULL));
    
    printf("POSIX Semaphore Benchmark\n");
    printf("=========================\n");
    printf("Operations: %ld increment/decrement cycles\n", numOps);
    
    // create semaphore with initial value 1
    sem_t *sem = sem_open(semName, O_CREAT | O_EXCL, 0644, 1);
    if (sem == SEM_FAILED)
        errExit("sem_open");
    
    // get start time
    struct timeval startTime, endTime;
    if (gettimeofday(&startTime, NULL) == -1)
        errExit("gettimeofday");
    
    // perform the benchmark: increment and decrement semaphore numOps times
    for (long i = 0; i < numOps; i++) {
        // decrement (wait)
        if (sem_wait(sem) == -1)
            errExit("sem_wait");
        
        // increment (post)
        if (sem_post(sem) == -1)
            errExit("sem_post");
    }
    
    // get end time
    if (gettimeofday(&endTime, NULL) == -1)
        errExit("gettimeofday");
    
    // calculate elapsed time
    double elapsed = (endTime.tv_sec - startTime.tv_sec) + 
                    (endTime.tv_usec - startTime.tv_usec) / 1000000.0;
    
    printf("Elapsed time: %.6f seconds\n", elapsed);
    printf("Operations per second: %.0f\n", (numOps * 2) / elapsed); // *2 because each cycle is wait+post
    printf("Average time per operation: %.9f seconds\n", elapsed / (numOps * 2));
    
    // cleanup
    if (sem_close(sem) == -1)
        errExit("sem_close");
    
    if (sem_unlink(semName) == -1)
        errExit("sem_unlink");
    
    exit(EXIT_SUCCESS);
}

```

## benchmark_sysv_sem.c
POSIX semaphore benchmark program

```C
#include <sys/time.h>
#include <sys/sem.h>
#include <time.h>
#include "tlpi_hdr.h"
#include "semun.h"

static void
usageError(const char *progName)
{
    fprintf(stderr, "Usage: %s num-operations\n", progName);
    fprintf(stderr, "  num-operations: number of increment/decrement cycles to perform\n");
    exit(EXIT_FAILURE);
}

// helper function to perform semaphore operation
static int
semOp(int semId, int semNum, int op)
{
    struct sembuf sop;
    
    sop.sem_num = semNum;
    sop.sem_op = op;
    sop.sem_flg = 0;  // no special flags for this benchmark
    
    return semop(semId, &sop, 1);
}

int
main(int argc, char *argv[])
{
    if (argc != 2 || strcmp(argv[1], "--help") == 0)
        usageError(argv[0]);

    long numOps = getLong(argv[1], GN_GT_0, "num-operations");
    
    printf("System V Semaphore Benchmark\n");
    printf("============================\n");
    printf("Operations: %ld increment/decrement cycles\n", numOps);
    
    // create semaphore set with 1 semaphore
    int semId = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | 0644);
    if (semId == -1)
        errExit("semget");
    
    // initialize semaphore to value 1
    union semun arg;
    arg.val = 1;
    if (semctl(semId, 0, SETVAL, arg) == -1)
        errExit("semctl SETVAL");
    
    // get start time
    struct timeval startTime, endTime;
    if (gettimeofday(&startTime, NULL) == -1)
        errExit("gettimeofday");
    
    // perform the benchmark: increment and decrement semaphore numOps times
    for (long i = 0; i < numOps; i++) {
        // decrement (wait) - subtract 1
        if (semOp(semId, 0, -1) == -1)
            errExit("semop wait");
        
        // increment (post) - add 1
        if (semOp(semId, 0, 1) == -1)
            errExit("semop post");
    }
    
    // get end time
    if (gettimeofday(&endTime, NULL) == -1)
        errExit("gettimeofday");
    
    // calculate elapsed time
    double elapsed = (endTime.tv_sec - startTime.tv_sec) + 
                    (endTime.tv_usec - startTime.tv_usec) / 1000000.0;
    
    printf("Elapsed time: %.6f seconds\n", elapsed);
    printf("Operations per second: %.0f\n", (numOps * 2) / elapsed); // *2 because each cycle is wait+post
    printf("Average time per operation: %.9f seconds\n", elapsed / (numOps * 2));
    
    // cleanup - remove semaphore set
    if (semctl(semId, 0, IPC_RMID) == -1)
        errExit("semctl IPC_RMID");
    
    exit(EXIT_SUCCESS);
}

```

## benchmark_comparison.sh
Script to run both benchmarks and summerize results

```sh
#!/bin/bash

echo "Semaphore Performance Comparison"
echo "================================"
echo
printf "| Operations | POSIX Time (s) | System V Time (s) | Speedup |\n"
printf "|------------|----------------|-------------------|----------|\n"

# Test with different operation counts
test_counts=(1000 10000 100000 1000000)

for count in "${test_counts[@]}"; do
    # Run POSIX benchmark and extract elapsed time
    posix_time=$(./benchmark_posix_sem $count | grep "Elapsed time:" | awk '{print $3}')
    
    # Run System V benchmark and extract elapsed time  
    sysv_time=$(./benchmark_sysv_sem $count | grep "Elapsed time:" | awk '{print $3}')
    
    # Calculate speedup ratio
    speedup=$(echo "scale=1; $sysv_time / $posix_time" | bc -l)
    
    printf "| %10s | %14s | %17s | %7.1fx |\n" "$count" "$posix_time" "$sysv_time" "$speedup"
done

```


# Results
```
$ ./benchmark_comparison.sh
Semaphore Performance Comparison
================================

| Operations | POSIX Time (s) | System V Time (s) | Speedup |
|------------|----------------|-------------------|----------|
|       1000 |       0.000013 |          0.000437 |    33.6x |
|      10000 |       0.000093 |          0.004251 |    45.7x |
|     100000 |       0.000944 |          0.044541 |    47.1x |
|    1000000 |       0.009119 |          0.439309 |    48.1x |
```


**Key Findings:**
- POSIX semaphores are **33-48x faster** than System V semaphores
- Performance difference increases with operation count (33.6x → 48.1x)
- POSIX achieves ~220M operations/second vs System V's ~4.5M operations/second
- Confirms TLPI's claim of "more than an order of magnitude" improvement
- The speedup stabilizes around 47-48x for larger operation counts



## Why POSIX Semaphores Perform Better
**POSIX Semaphores**: Operate in user space using atomic instructions when uncontended. System calls only needed when blocking occurs.
**System V Semaphores**: Every operation requires a system call (`semop()`), regardless of contention.

The 47x performance difference reflects the cost of system call overhead versus direct memory access.