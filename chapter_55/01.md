# a)
> Can a series of processes acquiring shared locks on a file starve a process attempting to place an exclusive lock on the file?

## test_starvation.sh
```sh
#!/bin/bash

touch testfile

echo "Starting shared lock holder (15 seconds)..."
./t_flock testfile s 15 &

sleep 2

echo "Starting exclusive lock request (will wait)..."
./t_flock testfile x 10 &
EXCLUSIVE_PID=$!

sleep 2

echo "Adding more shared lock requests while exclusive waits..."
./t_flock testfile s 5 &
./t_flock testfile s 5 &
./t_flock testfile s 5 &

wait

```

## Testing
```
$ ./test_starvation.sh 
Starting shared lock holder (15 seconds)...
PID 20579: requesting LOCK_SH at 23:19:12
PID 20579: granted    LOCK_SH at 23:19:12
Starting exclusive lock request (will wait)...
PID 20581: requesting LOCK_EX at 23:19:14
Adding more shared lock requests while exclusive waits...
PID 20583: requesting LOCK_SH at 23:19:16
PID 20583: granted    LOCK_SH at 23:19:16
PID 20584: requesting LOCK_SH at 23:19:16
PID 20584: granted    LOCK_SH at 23:19:16
PID 20585: requesting LOCK_SH at 23:19:16
PID 20585: granted    LOCK_SH at 23:19:16
PID 20583: releasing  LOCK_SH at 23:19:21
PID 20584: releasing  LOCK_SH at 23:19:21
PID 20585: releasing  LOCK_SH at 23:19:21
PID 20579: releasing  LOCK_SH at 23:19:27
PID 20581: granted    LOCK_EX at 23:19:27
PID 20581: releasing  LOCK_EX at 23:19:37
$ 
```

## Conclusion
**No starvation.** The exclusive lock (PID 20581) waited but was eventually granted after all shared locks released. New shared locks can be granted while an exclusive lock waits, but they don't prevent it from eventually succeeding.


# b)
> Suppose that a file is locked exclusively, and other processes are waiting to place both shared and exclusive locks on the file. When the first lock is released, are there any rules determining which process is next granted a lock? For example, do shared locks have priority over exclusive locks or vice versa? Are locks granted in FIFO order?

I've created a script to test this:
## test_priority.sh
```sh
#!/bin/bash
echo "Starting at: $(date '+%H:%M:%S')"

touch testfile

echo ""
echo "Starting exclusive lock holder (15 seconds)..."
./t_flock testfile x 15 &

echo ""
echo "Queueing lock requests in order:"
echo " - Shared lock #1"
./t_flock testfile s 3 &
./t_flock testfile x 3 &
./t_flock testfile s 3 &
./t_flock testfile x 3 &
./t_flock testfile s 3 &
./t_flock testfile x 3 &
./t_flock testfile s 3 &
./t_flock testfile x 3 &

# At this point all processes are queued.

echo ""
echo "Waiting for all background processes to complete..."
wait

```

## Testing

```
$ ./test_priority.sh
Starting at: 23:08:46

Starting exclusive lock holder (15 seconds)...

Queueing lock requests in order:

Waiting for all background processes to complete...
PID 20432: requesting LOCK_EX at 23:08:46
PID 20434: requesting LOCK_EX at 23:08:46
PID 20436: requesting LOCK_EX at 23:08:46
PID 20435: requesting LOCK_SH at 23:08:46
PID 20433: requesting LOCK_SH at 23:08:46
PID 20432: granted    LOCK_EX at 23:08:46
PID 20437: requesting LOCK_SH at 23:08:46
PID 20438: requesting LOCK_EX at 23:08:46
PID 20439: requesting LOCK_SH at 23:08:46
PID 20440: requesting LOCK_EX at 23:08:46
PID 20432: releasing  LOCK_EX at 23:09:01
PID 20434: granted    LOCK_EX at 23:09:01
PID 20434: releasing  LOCK_EX at 23:09:04
PID 20436: granted    LOCK_EX at 23:09:04
PID 20436: releasing  LOCK_EX at 23:09:07
PID 20435: granted    LOCK_SH at 23:09:07
PID 20433: granted    LOCK_SH at 23:09:07
PID 20439: granted    LOCK_SH at 23:09:07
PID 20437: granted    LOCK_SH at 23:09:07
PID 20435: releasing  LOCK_SH at 23:09:10
PID 20433: releasing  LOCK_SH at 23:09:10
PID 20439: releasing  LOCK_SH at 23:09:10
PID 20437: releasing  LOCK_SH at 23:09:10
PID 20438: granted    LOCK_EX at 23:09:10
PID 20438: releasing  LOCK_EX at 23:09:13
PID 20440: granted    LOCK_EX at 23:09:13
PID 20440: releasing  LOCK_EX at 23:09:16
$

## Conclusion
flock() uses FIFO for exclusive locks, but batches all waiting shared locks together.<br/>
Exclusive locks (20434 to 20436) granted in order, then all shared locks granted simultaneously, then remaining exclusive locks 20438 to 20440 in order.
```

# c)
> If you have access to some other UNIX implementation that provides flock(), try to determine the rules on that implementation.

## Testing on macOS (Darwin)

### Starvation Test
```
$ ./test_starvation.sh
Starting shared lock holder (15 seconds)...
PID 51611: requesting LOCK_SH at 23:24:48
PID 51611: granted    LOCK_SH at 23:24:48
Starting exclusive lock request (will wait)...
PID 51621: requesting LOCK_EX at 23:24:49
Adding more shared lock requests while exclusive waits...
PID 51627: requesting LOCK_SH at 23:24:51
PID 51627: granted    LOCK_SH at 23:24:51
PID 51628: requesting LOCK_SH at 23:24:51
PID 51628: granted    LOCK_SH at 23:24:51
PID 51629: requesting LOCK_SH at 23:24:51
PID 51629: granted    LOCK_SH at 23:24:51
PID 51627: releasing  LOCK_SH at 23:24:56
PID 51628: releasing  LOCK_SH at 23:24:56
PID 51629: releasing  LOCK_SH at 23:24:56
PID 51611: releasing  LOCK_SH at 23:25:03
PID 51621: granted    LOCK_EX at 23:25:03
PID 51621: releasing  LOCK_EX at 23:25:13
```

### Priority Test  
```
$ ./test_priority.sh
Starting at: 23:25:18
Starting exclusive lock holder (15 seconds)...
Queueing lock requests in order:
Waiting for all background processes to complete...
PID 51682: requesting LOCK_EX at 23:25:18
PID 51682: granted    LOCK_EX at 23:25:18
PID 51683: requesting LOCK_SH at 23:25:18
PID 51684: requesting LOCK_EX at 23:25:18
PID 51692: requesting LOCK_SH at 23:25:18
PID 51693: requesting LOCK_EX at 23:25:18
PID 51690: requesting LOCK_EX at 23:25:18
PID 51686: requesting LOCK_EX at 23:25:18
PID 51685: requesting LOCK_SH at 23:25:18
PID 51687: requesting LOCK_SH at 23:25:18
PID 51682: releasing  LOCK_EX at 23:25:33
PID 51683: granted    LOCK_SH at 23:25:33
PID 51683: releasing  LOCK_SH at 23:25:36
PID 51684: granted    LOCK_EX at 23:25:36
PID 51684: releasing  LOCK_EX at 23:25:39
PID 51692: granted    LOCK_SH at 23:25:39
PID 51692: releasing  LOCK_SH at 23:25:42
PID 51693: granted    LOCK_EX at 23:25:42
PID 51693: releasing  LOCK_EX at 23:25:45
PID 51690: granted    LOCK_EX at 23:25:45
PID 51690: releasing  LOCK_EX at 23:25:48
PID 51686: granted    LOCK_EX at 23:25:48
PID 51686: releasing  LOCK_EX at 23:25:51
PID 51685: granted    LOCK_SH at 23:25:51
PID 51685: releasing  LOCK_SH at 23:25:54
PID 51687: granted    LOCK_SH at 23:25:54
PID 51687: releasing  LOCK_SH at 23:25:57
```

## Conclusion
**macOS behavior differs from Linux.** On macOS, flock() grants locks in strict FIFO order regardless of type. Queue order: S(51683) -> E(51684) -> S(51692) -> E(51693) -> E(51690) -> E(51686)-> S(51685) -> S(51687).

Grant order: identical FIFO sequence. No batching of shared locks like Linux.


### A note regarding compilation on MacOS

The original `t_flock.c` didn't compile on macOS due to missing LOCK constants and flock() declaration. Added macOS-specific code:

```c
#ifdef __APPLE__
#include <sys/types.h>
#include <unistd.h>
/* macOS defines these in sys/file.h but they may not be visible with strict C99 */
#ifndef LOCK_SH
#define LOCK_SH   1    /* shared lock */
#define LOCK_EX   2    /* exclusive lock */
#define LOCK_NB   4    /* don't block when locking */
#define LOCK_UN   8    /* unlock */
#endif
/* Function declaration for flock */
int flock(int fd, int operation);
#endif
```

For the library issue, the proper solution (as documented in Chapter 11) is to use `libtool` instead of `ar`:
```bash
cd ../lib
make clean && make
rm -f ../libtlpi.a
libtool -c -static -o ../libtlpi.a *.o
```

Alternatively, compile with individual source files:
```bash
cc -D_DEFAULT_SOURCE -I../lib t_flock.c ../lib/curr_time.c ../lib/error_functions.c ../lib/get_num.c -o t_flock
```
