## Code
I wrote a small program to verify if:
- Mandatory locking is working
- Deadlock detection is working

[mandatory_deadlock_test.c](./mandatory_deadlock_test.c)
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <time.h>
#include <string.h>


static const char *
current_time()
{
    static char buf[64];
    time_t t = time(NULL);
    strftime(buf, sizeof(buf), "%T", localtime(&t));
    return buf;
}


static void
do_test(const char *file, int proc, int lock_start, int write_start)
{
    int fd;
    struct flock fl;
    char buf[10];

    printf("PID %d (P%d): Starting test at %s\n", getpid(), proc, current_time());

    fd = open(file, O_RDWR | O_CREAT, 0644);
    if (fd == -1) { perror("open"); exit(1); }

    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start = lock_start;
    fl.l_len = 10;

    printf("PID %d (P%d): Getting lock on bytes %d-%d\n", getpid(), proc, lock_start, lock_start+9);
    if (fcntl(fd, F_SETLKW, &fl) == -1) { perror("fcntl"); exit(1); }
    printf("PID %d (P%d): Got lock\n", getpid(), proc);

    sleep(1);

    printf("PID %d (P%d): Attempting write to bytes %d-%d\n", getpid(), proc, write_start, write_start+9);
    if (lseek(fd, write_start, SEEK_SET) == -1) { perror("lseek"); exit(1); }

    sprintf(buf, "P%d_data", proc);
    if (write(fd, buf, 10) == -1) {
        if (errno == EDEADLK)
            printf("PID %d (P%d): DEADLOCK DETECTED!\n", getpid(), proc);
        else if (errno == EAGAIN)
            printf("PID %d (P%d): Write blocked\n", getpid(), proc);
        else
            perror("write");
    } else {
        printf("PID %d (P%d): Write succeeded\n", getpid(), proc);
    }

    sleep(3);
    close(fd);
}


int
main()
{
    const char *file = "testfile";
    int fd;

    // Create and setup file
    fd = open(file, O_CREAT | O_RDWR | O_TRUNC, 0644);
    if (fd == -1) { perror("create"); exit(1); }
    write(fd, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", 36);
    close(fd);

    // Set mandatory locking permissions
    if (chmod(file, S_IRUSR | S_IWUSR | S_IRGRP | S_ISGID) == -1) {
        perror("chmod"); exit(1);
    }

    printf("Testing mandatory locking...\n");
    system("uname -r");

    // Create three processes with circular dependency
    pid_t p1 = fork();
    if (p1 == 0) {
        do_test(file, 2, 10, 0); // locks 10-19, writes to 0-9
        exit(0);
    }

    pid_t p2 = fork();
    if (p2 == 0) {
        do_test(file, 3, 20, 10); // locks 20-29, writes to 10-19
        exit(0);
    }

    do_test(file, 1, 0, 20); // locks 0-9, writes to 20-29

    wait(NULL);
    wait(NULL);
    unlink(file);
    return 0;
}

```



## Testing on Kernel version 6.x
I first tried to run this on a Linux with a modern kernel (for the time of writing this).

For this exercise I mounted an ext4 drive with the "mand" flag:
```
$ sudo mount -o mand /dev/sda /mnt/ext4-drive
$ mount | grep mand
/dev/sda on /mnt/ext4-drive type ext4 (rw,relatime,mand)
$ cd /mnt/ext4-drive
$ touch testfile
$ ls -l testfile
-rw-r-Sr-- 1 debian debian 67 Aug 29 21:19 testfile
```

But the test didn't work. Mandatory locking didn't work. Writing into a locked area by other processes was possible.
```
$./mandatory_deadlock_test
Testing mandatory locking...
6.1.55
PID 4129 (P1): Starting test at 01:31:54
PID 4133 (P3): Starting test at 01:31:54
PID 4132 (P2): Starting test at 01:31:54
PID 4133 (P3): Getting lock on bytes 20-29
PID 4129 (P1): Getting lock on bytes 0-9
PID 4133 (P3): Got lock
PID 4132 (P2): Getting lock on bytes 10-19
PID 4129 (P1): Got lock
PID 4132 (P2): Got lock
PID 4133 (P3): Attempting write to bytes 10-19
PID 4129 (P1): Attempting write to bytes 20-29
PID 4132 (P2): Attempting write to bytes 0-9
PID 4133 (P3): Write succeeded
PID 4129 (P1): Write succeeded
PID 4132 (P2): Write succeeded
$
```

Seem that the Kernal igores the "mand" mount flag entirely.

Searching the web shows -
Since Kernel v4.5 it was possible to disable mandatory locking

https://docs.kernel.org/5.10/filesystems/mandatory-locking.html
> Since kernel v4.5, it is possible to disable mandatory locking altogether by setting CONFIG_MANDATORY_FILE_LOCKING to “n”. A kernel with this disabled will reject attempts to mount filesystems with the “mand” mount option with the error status EPERM

Since v5.15 mandatory locking [has been fully removed](https://marc.info/?l=linux-kernel&m=163308941107833)

*Source: [Linux kernel commit removing mandatory locking](https://github.com/torvalds/linux/commit/f7e33bdbd6d1bdf9c3df8bba5abcf3399f957ac3) (v5.15)*


## Testing on Kernel version 2.6

To test this ancient relic, we need to travel back in time and run an older kernel. You might wonder why I even bother... well, I committed to reading this book cover-to-cover and completing every exercise. That might be a stupid commitment, but I also committed to fulfilling my commitments. So here we are.

Anyway...

I download an old CentOS image and used UTM (powered by QEMU) to virtualize it.<br/>
After a not so trivial setup process, I created a 10MB file with the `dd` command, formatted it as ext2 and mounted that file:
```
[root@localhost ~]# dd if=/dev/zero of=/tmp/testfs.img bs=1M count=10
10+0 records in
10+0 records out
10000000 bytes (10 MB) copied, 0.0921053 s,MB/s

[root@localhost ~]# mkfs.ext2 /tmp/testfs.img
mke2fs 1.41.12 (17-May-2010)
/tmp/testfs.img is not a block special device.
Proceed anyway? (y,n) y
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=0 blocks, Stripe width=0 blocks
2448 inodes, 9764 blocks
400 blocks (5.00%) reserved for the super user
First data block=1
Maximum filesystem blocks=10223616
2 block groups
8192 blocks per group, 8192 fragments per group
1224 inodes per group
Superblock backups stored on blocks:
        8193

Writing inode tables: done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 37 mounts or
180 days, whichever comes first. Use tune2fs -c or -i to override.
[root@localhost ~]# mkdir /mnt/test
[root@localhost ~]# mount -o loop,mand /tmp/testfs.img /mnt/test
[root@localhost ~]# mount | grep /mnt/test
/tmp/testfs.img on /mnt/test type ext2 (rw,mand,loop=/dev/loop0)
[root@localhost ~]#
```

We're in the game. We have an old linux machine, file system with the mand flag set. Let's create a test file:

```
[root@localhost ~]# cp ./simple_mandatory_test /mnt/test/
[root@localhost ~]# cd /mnt/test
[root@localhost test]# ./simple_mandatory_test
Testing mandatory locking...
2.6.32-754.el6.x86_64
PID 1494 (P1): Starting test at 17:44:34
PID 1494 (P1): Getting lock on bytes 0-9
PID 1497 (P3): Starting test at 17:44:34
PID 1496 (P2): Starting test at 17:44:34
PID 1496 (P2): Getting lock on bytes 10-19
PID 1497 (P3): Getting lock on bytes 20-29
PID 1497 (P3): Got lock
PID 1494 (P1): Got lock
PID 1496 (P2): Got lock
PID 1494 (P1): Attempting write to bytes 20-29
PID 1497 (P3): Attempting write to bytes 10-19
PID 1496 (P2): Attempting write to bytes 0-9
PID 1496 (P2): DEADLOCK DETECTED!
PID 1497 (P3): Write succeeded
PID 1494 (P1): Write succeeded
[root@localhost test]#
```

## Final Test on Kernel 2.6.32

Testing on CentOS 6 with kernel 2.6.32 in a UTM VM successfully demonstrated working mandatory locking: Process P2 received `DEADLOCK DETECTED!` when attempting to write to a region locked by another process, proving that old kernels enforce mandatory locking with I/O-level deadlock detection.

## Conclusions

**Mandatory locking evolution**:
- **Kernel 2.6.32 (2009)**: Full mandatory locking with I/O enforcement and deadlock detection
- **Modern kernels (5.15+)**: API compatibility maintained but enforcement completely disabled
* **Setup requirements work on all kernels**: `mount -o mand`, `chmod g+s,g-x` succeed everywhere
* **fcntl() locks work on all kernels**: Record locking itself functions normally
* **I/O enforcement differs dramatically**: Only old kernels actually block conflicting writes


## More about why mandatory locking was discouraged and removed:
The book mentioned race-conditions in the current implementation
> As a consequence of some kernel race conditions in the current Linux imple-
> mentation, there are circumstances in which system calls that perform I/O
> operations can succeed despite the presence of mandatory locks that should
> deny those operations.

This source tells more about it and the other shortcomings mandatory locks have - https://www.kernel.org/doc/Documentation/filesystems/mandatory-locking.txt

> 0. Why you should avoid mandatory locking
> -----------------------------------------
>
> The Linux implementation is prey to a number of difficult-to-fix race
> conditions which in practice make it not dependable:
>
> 	- The write system call checks for a mandatory lock only once
> 	  at its start.  It is therefore possible for a lock request to
> 	  be granted after this check but before the data is modified.
> 	  A process may then see file data change even while a mandatory
> 	  lock was held.
> 	- Similarly, an exclusive lock may be granted on a file after
> 	  the kernel has decided to proceed with a read, but before the
> 	  read has actually completed, and the reading process may see
> 	  the file data in a state which should not have been visible
> 	  to it.
> 	- Similar races make the claimed mutual exclusion between lock
> 	  and mmap similarly unreliable.
