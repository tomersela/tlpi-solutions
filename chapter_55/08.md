I used 3 i_fcntl_locking processes to create a circular dependency:

- Terminal 1 process first locks bytes 0-9
- Terminal 2 process first locks bytes 10-19
- Terminal 3 process first locks bytes 20-29

Then:
- Terminal 1 process locks bytes 10-19
- Terminal 2 process locks bytes 20-29
- Terminal 3 process locks bytes 0-9

This creates: A waits for, B waits for C, C waits for A

## Testing

Terminal 1 (Process A):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=4295> w w 0 10
[PID=4295] got lock
PID=4295>
```

Terminal 2 (Process B):
```
$ ../i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=4294> w w 10 10
[PID=4294] got lock
PID=4294>
```

Terminal 3 (Process C):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=4298> w w 20 10
[PID=4298] got lock
PID=4298>
```

Now, to create the circular dependency:

Terminal 1 (A tries to lock C's region):
```
PID=4295> w w 10 10
```
(blocks, waiting for Terminal 2 process to release the lock)

Terminal 2 (B tries to lock A's region):
```
PID=1002> w w 20 10
```
(blocks, waiting for Terminal 3 process to release the lock)

Terminal 3 (tries to lock Terminal 1 process region):
```
PID=4298> w w 0 10
[PID=4298] failed (deadlock)
PID=4298>
```

## Results

**Linux**: Process C received "failed (deadlock)" when attempting to complete the circular dependency, demonstrating that the Linux kernel successfully detects three-process circular deadlocks.

**macOS**: The same scenario also resulted in deadlock detection.

Both operating systems implement deadlock detection for fcntl() record locks involving multiple processes on the same file. The kernel prevents the circular wait condition by returning EDEADLK to one of the processes attempting to complete the cycle.