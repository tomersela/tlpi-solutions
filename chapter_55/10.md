# Background

`procmail` is a mail processing utility that can filter, sort, and forward email based on rules. It was commonly used on Unix systems for automated email handling.

The `lockfile` utility that comes with procmail is used to create semaphore files (lock files)
safely. It's designed for use in shell scripts to ensure mutual exclusion - only one instance of a
script can run at a time by acquiring a lock file.

### Example usage
Here's a typical scenario where procmail uses lockfile:

Imagine we have a mail server (e.g. sendmail/postfix) and we want to append a specific "inbox file" for every email arrived.

If multiple emails arrive simultaneously the mail server will spawn multiple procmail processes - one for each incoming email.

The problem - Multiple procmail processes might try to append to the same mailbox file at the same time, causing corruption.<br/>
The solution - Use lockfile to ensure only one process accesses the mailbox at a time

```bash
# Example procmail recipe (.procmailrc)
:0:
* ^From:.*important@company.com
{
    # before writing to mailbox, acquire lock
    lockfile /var/mail/user.lock

    # safely append email to mailbox file
    cat >> /var/mail/user

    # remove lock when done
    rm -f /var/mail/user.lock
}
```

#### Real-world Flow:

1. Email 2 arrives -> procmail process B starts
2. Email 1 arrives -> procmail process A starts
3. Process A: `lockfile /var/mail/user.lock` -> succeeds, gets lock
4. Process B: `lockfile /var/mail/user.lock` -> waits (lock exists)
5. Process A: writes email to mailbox, removes lock
6. Process B: lock gone, now acquires lock and writes its email

This prevents mailbox corruption from concurrent writes. The `lockfile` utility ensures atomic lock creation and proper cleanup, making it safe for multiple processes to coordinate access to shared resources.


## Requirements (Key Features of lockfile(1))

From the man page, the lockfile utility provides:

- **Atomic lock creation**: Uses `open()` with `O_CREAT | O_EXCL` flags for atomic lock file creation
- **Cleanup Tracking**: Maintains a list of created files for cleanup on failure or signal
- **Retry mechanism**: Configurable sleep time and retry count
- **All-or-nothing**: If it can't create all specified files, it removes any it did create
- **Stale lock removal**: Can force-remove locks older than a timeout (Checks file modification time against timeout)
- **Signal handling**: Installs handlers for SIGINT/SIGTERM to clean up locks
- **Invert flag**: Can invert exit status for use in shell loops


# Implementation
This implementation covers the core functionality of the original lockfile utility.

I chose not to use fcntl() or flock() (as with the original `lockfile` util).

This implementation uses the "older technique" described in Section 55.7 of TLPI: `open(file, O_CREAT | O_EXCL, ...)` plus `unlink(file)`. While the book notes this approach is "superseded by fcntl() record locking,".

### Why Not Just Use flock()?

The original procmail lockfile utility predates widespread fcntl() support. The exercise asks to implement lockfile(1), not improve upon it. Also,the original procmail utility was designed to work across NFS version 2, which didn't support fcntl() locking reliably

The book correctly identifies limitations of this approach (polling vs blocking, slower filesystem operations, no automatic cleanup on crash, no deadlock detection), but these tradeoffs were acceptable for the original utility's mail-processing use case.


[simple_lockfile.c](./simple_lockfile.c)

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <sys/stat.h>
#include <signal.h>
#include <getopt.h>

#include "tlpi_hdr.h"


static char **created_files = NULL;
static int num_created = 0;
static int max_files = 0;


// cleanup function for signal handling
static void
cleanup_and_exit(int sig)
{
    for (int i = 0; i < num_created; i++) {
        unlink(created_files[i]);
    }
    exit(EXIT_FAILURE);
}


// add a file to the cleanup list
static void
add_created_file(const char *filename)
{
    if (num_created >= max_files) {
        max_files = max_files ? max_files * 2 : 16;
        created_files = realloc(created_files, max_files * sizeof(char*));
        if (!created_files)
            errExit("realloc");
    }
    created_files[num_created] = strdup(filename);
    if (!created_files[num_created])
        errExit("strdup");
    num_created++;
}


// check if lockfile is stale (older than timeout)
static int
is_stale_lockfile(const char *filename, int timeout)
{
    struct stat st;
    time_t now;

    if (stat(filename, &st) == -1)
        return 0; // file doesn't exist, not stale

    time(&now);
    return (now - st.st_mtime) > timeout;
}


// try to create a single lockfile atomically
// returns: 0 = success, 1 = already exists, -1 = other error
static int
try_create_lockfile(const char *filename)
{
    int fd;

    // try to create file exclusively (atomic operation)
    fd = open(filename, O_CREAT | O_EXCL | O_WRONLY, S_IRUSR | S_IRGRP | S_IROTH);
    if (fd == -1) {
        if (errno == EEXIST)
            return 1; // lockfile already exists
        else
            return -1; // other error
    }

    // write our PID to the lockfile
    dprintf(fd, "%ld\n", (long) getpid());
    close(fd);
    return 0; // success
}


// usage information
static void
usage(const char *progname)
{
    fprintf(stderr, "Usage: %s [options] filename...\n", progname);
    fprintf(stderr, "Options:\n");
    fprintf(stderr, "  -s sleeptime    Sleep time between retries (default: 8)\n");
    fprintf(stderr, "  -r retries      Number of retries (-1 = forever, default: -1)\n");
    fprintf(stderr, "  -l timeout      Lock timeout in seconds (force removal)\n");
    fprintf(stderr, "  -!              Invert exit status\n");
    fprintf(stderr, "  -h              Show this help\n");
}


int
main(int argc, char *argv[])
{
    int sleeptime = 8;
    int retries = -1;
    int locktimeout = 0;
    int invert_status = 0;
    int opt;
    int success = 1;

    // install signal handlers for cleanup
    signal(SIGINT, cleanup_and_exit);
    signal(SIGTERM, cleanup_and_exit);

    // parse command line options
    while ((opt = getopt(argc, argv, "s:r:l:!h")) != -1) {
        switch (opt) {
            case 's':
                sleeptime = atoi(optarg);
                if (sleeptime < 0) sleeptime = 8;
                break;
            case 'r':
                retries = atoi(optarg);
                break;
            case 'l':
                locktimeout = atoi(optarg);
                if (locktimeout < 0) locktimeout = 0;
                break;
            case '!':
                invert_status = !invert_status;
                break;
            case 'h':
                usage(argv[0]);
                exit(EXIT_SUCCESS);
            default:
                usage(argv[0]);
                exit(EXIT_FAILURE);
        }
    }

    if (optind >= argc) {
        fprintf(stderr, "Error: No filenames specified\n");
        usage(argv[0]);
        exit(EXIT_FAILURE);
    }

    // try to create all specified lockfiles
    for (int i = optind; i < argc; i++) {
        const char *filename = argv[i];
        int attempts = 0;
        int created = 0;


        // retry logic
        while (!created && (retries == -1 || attempts < retries)) {
            int result = try_create_lockfile(filename);

            if (result == 0) {
                // successfully created
                add_created_file(filename);
                created = 1;
                break;
            } else if (result == -1) {
                // error other than EEXIST
                fprintf(stderr, "Error creating lockfile '%s': %s\n",
                        filename, strerror(errno));
                success = 0;
                break;
            }

            // result == 1: lockfile already exists, continue -  check if it's stale and retry again

            if (locktimeout > 0 && is_stale_lockfile(filename, locktimeout)) {
                printf("Forcing lock on \"%s\"\n", filename);
                if (unlink(filename) == -1) {
                    if (errno == EACCES || errno == EPERM) {
                        fprintf(stderr, "Forced unlock denied on \"%s\"\n", filename);
                        success = 0;
                        break;
                    }
                }
                continue; // try again after removing stale lock
            }

            attempts++;
            if (retries != -1 && attempts >= retries) {
                fprintf(stderr, "Sorry, giving up on \"%s\"\n", filename);
                success = 0;
                break;
            }

            sleep(sleeptime);
        }

        if (!created) {
            success = 0;
            break;
        }
    }

    // if we failed, clean up all created files
    if (!success) {
        for (int i = 0; i < num_created; i++) {
            unlink(created_files[i]);
        }
    }

    // cleanup memory
    for (int i = 0; i < num_created; i++) {
        free(created_files[i]);
    }
    free(created_files);

    int exit_status = success ? EXIT_SUCCESS : EXIT_FAILURE;
    return invert_status ? !exit_status : exit_status;
}

```

# Testing


```bash
#!/bin/bash

echo "TEST: basic lockfile creation"
./simple_lockfile test.lock
if [ -f test.lock ]; then
    echo "SUCCESS: lockfile created"
    rm -f test.lock
else
    echo "FAILED: lockfile not created"
fi
echo ""

echo "TEST: lockfile already exists"
touch existing.lock
./simple_lockfile -r 0 existing.lock
if [ $? -ne 0 ]; then
    echo "SUCCESS: correctly failed when lockfile exists"
else
    echo "FAILED: should have failed when lockfile exists"
fi
rm -f existing.lock
echo ""


echo "TEST: multiple lockfiles"
./simple_lockfile lock1.lock lock2.lock lock3.lock
if [ -f lock1.lock ] && [ -f lock2.lock ] && [ -f lock3.lock ]; then
    echo "SUCCESS: all lockfiles created"
    rm -f lock1.lock lock2.lock lock3.lock
else
    echo "FAILED: not all lockfiles created"
    rm -f lock1.lock lock2.lock lock3.lock
fi
echo ""


echo "TEST: cleanup on partial failure"
touch existing.lock
./simple_lockfile -r 0 temp1.lock existing.lock temp2.lock
if [ ! -f temp1.lock ] && [ ! -f temp2.lock ]; then
    echo "SUCCESS: cleanup worked on partial failure"
else
    echo "FAILED: cleanup didn't work"
    rm -f temp1.lock temp2.lock
fi
rm -f existing.lock
echo ""


echo "TEST: invert flag"
touch existing.lock
./simple_lockfile -! -r 0 existing.lock
if [ $? -eq 0 ]; then
    echo "SUCCESS: invert flag worked"
else
    echo "FAILED: invert flag didn't work"
fi
rm -f existing.lock
echo ""


echo "TEST: retry and timeout (creating competing lock)"
touch competing.lock &
LOCK_PID=$!
./simple_lockfile -r 2 -s 1 competing.lock &
TEST_PID=$!
sleep 3
kill $LOCK_PID 2>/dev/null
wait $TEST_PID
RESULT=$?
if [ $RESULT -ne 0 ]; then
    echo "SUCCESS: correctly timed out after retries"
else
    echo "FAILED: should have timed out"
fi
rm -f competing.lock

```

## Test Results
```
$ ./simple_lockfile_test.sh
TEST: basic lockfile creation
SUCCESS: lockfile created

TEST: lockfile already exists
SUCCESS: correctly failed when lockfile exists

TEST: multiple lockfiles
SUCCESS: all lockfiles created

TEST: cleanup on partial failure
SUCCESS: cleanup worked on partial failure

TEST: invert flag
SUCCESS: invert flag worked

TEST: retry and timeout (creating competing lock)
Sorry, giving up on "competing.lock"
SUCCESS: correctly timed out after retries
```
