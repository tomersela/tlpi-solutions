> Experiment by running the programs in Listing 55-1 (t_flock.c) and Listing 55-2 (i_fcntl_locking.c) to see whether locks granted by flock() and fcntl() have any effect on one another.

**Summary:** flock() and fcntl() locks interact. Blocking fcntl() commands wait for flock() locks to release. Non-blocking fcntl() commands fail immediately when flock() holds a lock.

> If you have access to other UNIX implementations, try the same experiment on those implementations.

The interaction behavior depends on the filesystem:
- **ext4 (traditional Linux filesystem)**: flock() and fcntl() operate independently (matches the book answer to this exercise)
- **9p filesystem (shared folders in VM)**: flock() and fcntl() interact with each other
- **MacOS filesystems**: flock() and fcntl() interact with each other


## Test Matrix for ext4 filesystem

| Test | First Lock | Second Lock | Result | Behavior |
|------|------------|-------------|--------|----------|
| 1 | flock() exclusive | fcntl() write (w) | Allowed | independent |
| 2 | flock() exclusive | fcntl() read (w) | Allowed | independent |
| 3 | flock() shared | fcntl() write (w) | Allowed | independent |
| 4 | flock() shared | fcntl() read | Allowed | independent |
| 5 | fcntl() write | flock() exclusive | Allowed | independent |
| 6 | fcntl() write | flock() shared | Allowed | independent |
| 7 | fcntl() read | flock() exclusive | Allowed | independent |
| 8 | fcntl() read | flock() shared | Allowed | independent |

**ext4 Summary:** flock() and fcntl() locks operate independently - both can be acquired simultaneously on the same file.

## Test Matrix and Results for MacOS (and 9p fs on linux with MacOS host)

| Test | First Lock | Second Lock | Result | Behavior |
|------|------------|-------------|--------|----------|
| 1 | flock() exclusive | fcntl() write (w) | Blocked | waits for release |
| 2 | flock() exclusive | fcntl() read (w) | Blocked | waits for release |
| 3 | flock() shared | fcntl() write (w) | Succeeds | waits then acquires |
| 4 | flock() shared | fcntl() read | Allowed | compatible |
| 5 | fcntl() write | flock() exclusive | Blocked | waits for release |
| 6 | fcntl() write | flock() shared | Blocked | waits for release |
| 7 | fcntl() read | flock() exclusive | Blocked | waits for release |
| 8 | fcntl() read | flock() shared | Allowed | compatible |


## Test Details

There are 8 combinations we can test given these variants:
- fcntl - can use write vs read lock
- flock - can use exclusive vs shared
- locking order - fcntl first vs flock first

Note: There are more variations I could consider:
- fcntl() can lock an entire file or a a specific byte range. In all tests I considered a specific byte range.
- I used only blocking calls in fcntl locks (`w w 10 10`,  `w r 10 10`)


First, we'll create a test file with some content:
```
$ echo "This is a test file with more than 20 bytes of content for testing" > testfile
```


# Results for ext4 fs on Linux

## Test Group A: flock() exclusive vs all fcntl() lock types

Terminal 1:
```
$ ./t_flock testfile x 60
PID 28554: requesting LOCK_EX at 01:29:58
PID 28554: granted    LOCK_EX at 01:29:58
```

Terminal 2 (while Terminal 1 is running):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=28553> w w 10 10
[PID=28553] got lock
PID=28553>
```

Now running the same lock on Terminal 1:
```
PID 28554: releasing  LOCK_EX at 01:30:58
$ ./t_flock testfile x 60
PID 28581: requesting LOCK_EX at 01:39:03
PID 28581: granted    LOCK_EX at 01:39:03
```

Back to Terminal 2, this time checking read lock:
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=28580> w r 10 10
[PID=28580] got lock
PID=28580>
```


**Results:** fcntl() and flock() are independent from each other.


## Test Group B: fcntl() write lock vs flock() locks

Terminal 1 (fcntl() write lock):
```
$ ../i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=28591> w w 10 10
[PID=28591] got lock
PID=28591>
```

Terminal 2 - Test against flock() exclusive:
```
$ ./t_flock testfile x 10
PID 28600: requesting LOCK_EX at 01:40:35
PID 28600: granted    LOCK_EX at 01:40:35
```
Lock granted. showing independency of the mechanisms.

Now back to Terminal 1, running the same experiment with a write lock:
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=28632> w r 10 10
[PID=28632] got lock
PID=28632>
```

Terminal 2 - Test against flock() shared:
```
$ ./t_flock testfile x 10
PID 28640: requesting LOCK_EX at 01:42:48
PID 28640: granted    LOCK_EX at 01:42:48
```

**Results:** fcntl() and flock() are independent from each other.


## Test Group C: flock() shared vs fcntl() locks

Terminal 1 (flock() shared lock):
```
$ ./t_flock testfile s 30
PID 28697: requesting LOCK_SH at 01:44:39
PID 28697: granted    LOCK_SH at 01:44:39
```

Terminal 2 - Test against fcntl() write:
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=28696> w w 10 10
[PID=28696] got lock
PID=28696>
```

Now we'll use flock() shared lock again on Terminal 1:
```
$ ./t_flock testfile s 30
PID 28720: requesting LOCK_SH at 01:46:18
PID 28720: granted    LOCK_SH at 01:46:18
```

and on Terminal 2 - Test against fcntl() read:
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=28719> w r 10 10
[PID=28719] got lock
PID=28719>
```

**Results:** fcntl() and flock() are independent from each other.


## Test Group D: fcntl() read lock vs flock() locks

Terminal 1 (fcntl() read lock):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=26260> w r 10 10
[PID=26260] got lock
PID=26260>
```

Terminal 2 - Test against flock() exclusive and shared:
```
$ ./t_flock testfile x 10
PID 28739: requesting LOCK_EX at 01:47:49
PID 28739: granted    LOCK_EX at 01:47:49
PID 28739: releasing  LOCK_EX at 01:47:59
$ ./t_flock testfile s 10
PID 28745: requesting LOCK_SH at 01:48:01
PID 28745: granted    LOCK_SH at 01:48:01
PID 28745: releasing  LOCK_SH at 01:48:11
```

**Results:** fcntl() and flock() are independent from each other.


# Results for Linux 9p fs (hosted by MacOS) and MacOS:

## Test Group A: flock() exclusive vs all fcntl() lock types

Terminal 1:
```
$ ./t_flock testfile x 60
PID 25763: requesting LOCK_EX at 22:33:21
PID 25763: granted    LOCK_EX at 22:33:21
```

Terminal 2 (while Terminal 1 is running):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=25750> w w 10 10
```
(blocks here, waiting for flock to release...)

Back to Terminal 1 (after 60 seconds):
```
PID 25763: releasing  LOCK_EX at 22:34:21
```

Back to Terminal 2 (immediately after flock releases):
```
[PID=25750] got lock
PID=25750> %
```

Again, locking with flock on Terminal 1:
```
$ ./t_flock testfile x 60
```

Now trying to aquire a read fcntl lock on Terminal 2:
```
./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=25881> w r 10 10
```
(blocks here, waiting for flock to release...)


**Results:** Blocking fcntl() (`w`) waits for flock() to release, then succeeds.


## Test Group B: fcntl() write lock vs flock() locks

Terminal 1 (fcntl() write lock):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=25985> w w 10 10
[PID=25985] got lock
PID=25985>
```

Terminal 2 - Test against flock() exclusive:
```
$ ./t_flock testfile x 10
PID 25987: requesting LOCK_EX at 22:42:55
```
It hangs. waiting for the fcntl lock to release.

Releasing fcntl() lock from Terminal 1:
```
PID=25985> s u 10 10
[PID=25985] unlocked
PID=25985>
```

Terminal 2 continues:
```
PID 25987: granted    LOCK_EX at 22:43:07
PID 25987: releasing  LOCK_EX at 22:43:17
```

Now back to Terminal 1, we block again with a write lock:
```
PID=25985> w w 10 10
```

Terminal 2 - Test against flock() shared:
```
$ ./t_flock testfile s 10
```
(same blocking behavior - waits for fcntl write lock)

**Results:** fcntl() write lock blocks both flock() exclusive and shared locks. Both flock() types wait for fcntl() to release.


## Test Group C: flock() shared vs fcntl() locks

Terminal 1 (flock() shared lock):
```
$ ./t_flock testfile s 30
PID 26127: requesting LOCK_SH at 23:07:24
PID 26127: granted    LOCK_SH at 23:07:24
```

Terminal 2 - Test against fcntl() write:
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=26125> w w 10 10
```
(blocks, waiting for flock shared lock to release...)

After the lock is released on Terminal 1, we can see the following on Terminal 2:
```
[PID=26125] got lock
PID=26125> ^C
```
(I typed Ctrl+C to release the fcntl lock)


Now we'll use flock() shared lock again on Terminal 1:
```
$ ./t_flock testfile s 30
PID 26187: requesting LOCK_SH at 23:12:18
PID 26187: granted    LOCK_SH at 23:12:18
```

and on Terminal 2 - Test against fcntl() read:
```
./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=26186> w r 10 10
[PID=26186] got lock
PID=26186> w u 10 10
[PID=26186] unlocked
```

**Results:**
- fcntl() write locks are incompatible with flock() shared (blocking waits)
- fcntl() read locks are compatible with flock() shared (succeeds immediately)


## Test Group D: fcntl() read lock vs flock() locks

Terminal 1 (fcntl() read lock):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=26260> w r 10 10
[PID=26260] got lock
PID=26260>
```

Terminal 2 - Test against flock() exclusive:
```
$ ./t_flock testfile x 10
PID 26262: requesting LOCK_EX at 23:14:27
^C
$
```
(blocks, waiting for fcntl read lock to release... I typed Ctrl+C to remove the flock request)

Terminal 2 - Test against flock() shared:
```
$ ./t_flock testfile s 10
PID 26284: requesting LOCK_SH at 23:16:03
PID 26284: granted    LOCK_SH at 23:16:03
PID 26284: releasing  LOCK_SH at 23:16:13
```
(succeeds immediately - compatible)

**Results:**
- fcntl() read lock blocks flock() exclusive (waits for release)
- fcntl() read lock is compatible with flock() shared (succeeds immediately)