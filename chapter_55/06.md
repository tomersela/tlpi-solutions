## Section 55.3.6 Statements to Verify

1. **Starvation**: Read locks can starve write locks indefinitely
2. **No FIFO**: Lock order is indeterminate, depends on process scheduling
3. **No priority**: Writers don't have priority over readers, and vice versa

## Test 1: Read Lock Starvation of Write Locks

Terminal 1 (establish read lock):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=27683> w r 0 0
[PID=27683] got lock
PID=27683>
```

Terminal 2 (writer waits):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=27688> w w 10 10

```
(blocks, waiting for read lock to release...)

Terminal 3 (add another reader while writer waits):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=27734> w r 10 10
[PID=27734] got lock
PID=27734>
```

Now back to Terminal 1, releasing the read lock:
```
$ PID=27683> w u 0 0
[PID=27683] unlocked
PID=27683>
```

We can then go back to Terminal 2 and see that the writer still waits.

**Conculaion**: New readers can acquire locks while writer waits, demonstrating starvation.


## Test 2: Lock Priority and Ordering

Terminal 1 (establish write lock):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=27985> w w 0 0
[PID=27985] got lock
```

Queue multiple lock requests in different terminals:
- Terminal 2: `w r 0 0` (reader)
- Terminal 3: `w w 0 0` (writer)
- Terminal 4: `w r 0 0` (reader)
- Terminal 5: `w w 0 0` (writer)

Then release from Terminal 1:
```
PID=27985> s u 0 0
[PID=27985] unlocked
```

## Results

### Test Order 1: Reader-Writer-Reader-Writer Queue
When queued in order: Reader(T2) -> Writer(T3) -> Reader(T4) -> Writer(T5)
- **Result**: Both readers (T2, T4) acquired locks simultaneously, then writers got locks in order (T3, T5)
- **Consistent across multiple runs**

### Test Order 2: Writer-Reader-Reader-Writer Queue
When queued in order: Writer(T2) -> Reader(T3) -> Reader(T4) -> Writer(T5)
- **Result**: First writer (T2) acquired lock immediately, then readers, then remaining writer
- **Consistent across multiple runs**


## Analysis

I couldn't prove the claim about fcntl() lock ordering being "indeterminate."

The behavior I observed was actually seem to use FIFO ordering - Locks are granted in the order requested. However, multiple readers can be granted simultaneously within FIFO order.

This contradicts Section 55.3.6's claim that "the order in which queued lock requests are granted is indeterminate." The behavior was quite deterministic among few runs.
