# Code

## lock_acquirer.c
Acquires 40,001 write locks on alternating bytes (0, 2, 4, ..., 80,000) and sleeps.

```C
/* lock_acquirer.c

   Program to acquire 40,001 write locks on alternating bytes of a file.
   Locks are placed on bytes 0, 2, 4, 6, ... up to byte 80,000.
   After acquiring locks, the process sleeps to allow testing.

   Usage: ./lock_acquirer filename
*/

#include <sys/file.h>
#include <fcntl.h>
#ifdef __APPLE__
#include <sys/types.h>
#include <unistd.h>
#endif
#include "curr_time.h"
#include "tlpi_hdr.h"

#define NUM_LOCKS 40001
#define MAX_BYTE 80000


int
main(int argc, char *argv[])
{
    int fd;
    struct flock fl;
    int lock_count = 0;
    
    if (argc != 2 || strcmp(argv[1], "--help") == 0)
        usageErr("%s filename\n", argv[0]);

    printf("Starting lock acquisition at %s\n", currTime("%T"));
    printf("Acquiring %d locks on alternating bytes (0, 2, 4, ... %d)\n", 
           NUM_LOCKS, MAX_BYTE);

    // open file for writing, create if doesn't exist
    fd = open(argv[1], O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
    if (fd == -1)
        errExit("open %s", argv[1]);

    // ensure file is large enough
    if (lseek(fd, MAX_BYTE, SEEK_SET) == -1)
        errExit("lseek");
    if (write(fd, "x", 1) == -1)
        errExit("write");

    // acquire locks on alternating bytes
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_len = 1;  // lock single byte

    for (int byte_pos = 0; byte_pos <= MAX_BYTE; byte_pos += 2) {
        fl.l_start = byte_pos;
        
        if (fcntl(fd, F_SETLK, &fl) == -1) {
            if (errno == EACCES || errno == EAGAIN) {
                printf("Lock conflict at byte %d (unexpected)\n", byte_pos);
                continue;
            } else {
                errExit("fcntl F_SETLK at byte %d", byte_pos);
            }
        }
        
        lock_count++;
        
        // progress indicator
        if (lock_count % 5000 == 0) {
            printf("Acquired %d locks so far... (current byte: %d)\n", 
                   lock_count, byte_pos);
        }
    }

    printf("Successfully acquired %d locks at %s\n", lock_count, currTime("%T"));
    printf("Process PID: %ld\n", (long) getpid());
    printf("Sleeping indefinitely... Press Ctrl+C to exit\n");

    // sleep indefinitely to keep locks active
    while (1) {
        sleep(3600);  // sleep for 1 hour at a time
    }

    // this won't be reached, but good practice
    close(fd);
    return 0;
}

```

## lock_tester.c
```C
/* lock_tester.c

   Program to test fcntl() lock checking performance.
   Attempts to lock a specific byte N*2 that should already be locked
   by lock_acquirer, repeating the attempt many times to measure timing.

   Usage: ./lock_tester filename N iterations
   Where:
   - filename: same file used by lock_acquirer
   - N: the position multiplier (tests locking byte N*2)
   - iterations: number of lock attempts to make (default 10000)
*/

#include <sys/file.h>
#include <fcntl.h>
#ifdef __APPLE__
#include <sys/types.h>
#include <unistd.h>
#endif
#include "curr_time.h"
#include "tlpi_hdr.h"

int
main(int argc, char *argv[])
{
    int fd;
    struct flock fl;
    int n, iterations = 10000;
    int byte_pos;
    int attempts = 0, failures = 0;
    
    if (argc < 3 || strcmp(argv[1], "--help") == 0)
        usageErr("%s filename N [iterations]\n"
                 "  filename: file with existing locks\n"
                 "  N: position multiplier (tests byte N*2)\n"
                 "  iterations: number of attempts (default 10000)\n", argv[0]);

    n = getInt(argv[2], GN_NONNEG, "N");
    if (argc > 3)
        iterations = getInt(argv[3], GN_GT_0, "iterations");

    byte_pos = n * 2;

    printf("Testing lock attempts on byte %d (%d iterations)\n", byte_pos, iterations);
    printf("Starting test at %s\n", currTime("%T"));

    // open file
    fd = open(argv[1], O_RDWR);
    if (fd == -1)
        errExit("open %s", argv[1]);

    // set up lock structure
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start = byte_pos;
    fl.l_len = 1;  // lock single byte

    // perform lock attempts in a tight loop
    for (int i = 0; i < iterations; i++) {
        attempts++;
        
        if (fcntl(fd, F_SETLK, &fl) == -1) {
            if (errno == EACCES || errno == EAGAIN) {
                failures++;  // expected - byte should be locked
            } else {
                errExit("fcntl F_SETLK");
            }
        } else {
            // unexpected success - unlock immediately
            fl.l_type = F_UNLCK;
            fcntl(fd, F_SETLK, &fl);
            fl.l_type = F_WRLCK;  // reset for next attempt
        }
    }

    printf("Completed test at %s\n", currTime("%T"));
    printf("Attempts: %d, Failures (expected): %d, Success: %d\n", 
           attempts, failures, attempts - failures);

    close(fd);
    return 0;
}

```


# Testing

## test_lock_performance.sh
Measures timing for N = 0, 10,000, 20,000, 30,000, 40,000.

```bash
#!/bin/bash

TEST_FILE="locktest.dat"
ITERATIONS=10000

if ! pgrep -f "lock_acquirer.*$TEST_FILE" > /dev/null; then
    echo "Start lock_acquirer first: ./lock_acquirer $TEST_FILE &"
    exit 1
fi

for n in 0 10000 20000 30000 40000; do
    echo "N=$n (byte $((n * 2)))"
    time ./lock_tester "$TEST_FILE" "$n" "$ITERATIONS"
    echo
done

```

First we run lock_acquirer in the background to acquire 40,001 locks on alternating bytes.<br/>
Once all locks are established and the process is sleeping, we run the performance test script to measure how long it takes to check for locks at different positions in the kernel's lock list.

```
$ ./lock_acquirer locktest.dat &
[1] 27319
Starting lock acquisition at 23:45:21                                                                                                                                         
Acquiring 40001 locks on alternating bytes (0, 2, 4, ... 80000)
$ Acquired 5000 locks so far... (current byte: 9998)
Acquired 10000 locks so far... (current byte: 19998)
Acquired 15000 locks so far... (current byte: 29998)
Acquired 20000 locks so far... (current byte: 39998)
Acquired 25000 locks so far... (current byte: 49998)
Acquired 30000 locks so far... (current byte: 59998)
Acquired 35000 locks so far... (current byte: 69998)
Acquired 40000 locks so far... (current byte: 79998)
Successfully acquired 40001 locks at 23:45:57
Process PID: 27319
Sleeping indefinitely... Press Ctrl+C to exit

$ ./test_lock_performance.sh    
N=0 (byte 0)
Testing lock attempts on byte 0 (10000 iterations)
Starting test at 23:46:25
Completed test at 23:46:25
Attempts: 10000, Failures (expected): 10000, Success: 0

real	0m0.018s
user	0m0.000s
sys	0m0.013s

N=10000 (byte 20000)
Testing lock attempts on byte 20000 (10000 iterations)
Starting test at 23:46:25
Completed test at 23:46:26
Attempts: 10000, Failures (expected): 10000, Success: 0

real	0m0.691s
user	0m0.004s
sys	0m0.682s

N=20000 (byte 40000)
Testing lock attempts on byte 40000 (10000 iterations)
Starting test at 23:46:26
Completed test at 23:46:27
Attempts: 10000, Failures (expected): 10000, Success: 0

real	0m1.518s
user	0m0.004s
sys	0m1.506s

N=30000 (byte 60000)
Testing lock attempts on byte 60000 (10000 iterations)
Starting test at 23:46:27
Completed test at 23:46:30
Attempts: 10000, Failures (expected): 10000, Success: 0

real	0m2.928s
user	0m0.004s
sys	0m2.916s

N=40000 (byte 80000)
Testing lock attempts on byte 80000 (10000 iterations)
Starting test at 23:46:30
Completed test at 23:46:36
Attempts: 10000, Failures (expected): 10000, Success: 0

real	0m5.688s
user	0m0.004s
sys	0m5.670s
```

**Analysis:** Linear behavior confirmed. Time increases proportionally with lock position in the kernel's lock list:
- N=0: 0.018s (beginning of list)
- N=40000: 5.688s (end of list) 
- ~316x slower for position at end vs beginning

This verifies Section 55.3.4's statement that Linux fcntl() uses O(n) linear search through the lock list.
