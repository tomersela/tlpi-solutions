I tested on MacOS and got the same behavior as in the [solution to Exercise 55.6](06.md):


## Test 1: Read Lock Starvation of Write Locks


Terminal 1 (establish read lock):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=862> w r 0 0
[PID=862] got lock
PID=862>
```

Terminal 2 (writer waits):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=882> w w 10 10
```
(blocks, waiting for read lock to release...)

Terminal 3 (add another reader while writer waits):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=885> w r 10 10
[PID=885] got lock
PID=885>
```

Now back to Terminal 1, releasing the read lock:
```
$ PID=27683> w u 0 0
[PID=27683] unlocked
PID=27683>
```

We can then go back to Terminal 2 and see that the writer still waits.


## Test 2: Lock Priority and Ordering

Terminal 1 (establish write lock):
```
$ ./i_fcntl_locking testfile
File       Locking
----       -------
testfile   advisory

Enter ? for help
PID=1841> w w 0 0
[PID=1841] got lock
```

Queue multiple lock requests in different terminals:
- Terminal 2: `w r 0 0` (reader)
- Terminal 3: `w w 0 0` (writer)
- Terminal 4: `w r 0 0` (reader)
- Terminal 5: `w w 0 0` (writer)

Then release from Terminal 1:
```
PID=1841> w u 0 0
[PID=1841] unlocked
PID=1841>
```


## Results

Terminal 5 acquired the lock despite not being first in queue, demonstrating indeterminate ordering on macOS.

This matches Section 55.3.6's description that "the order in which queued lock requests are granted is indeterminate" and depends on process scheduling.