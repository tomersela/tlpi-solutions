# select_self_pipe.c
```diff
--- ./self_pipe.c	2025-10-14 23:53:37.601526515 +0300
+++ ./select_self_pipe.c	2025-10-15 00:20:57.151313719 +0300
@@ -8,21 +8,22 @@
 * the file COPYING.gpl-v3 for details.                                    *
 \*************************************************************************/
 
-/* Listing 63-9 */
+/* Exercise 63-4 - Modified to use poll() instead of select() */
 
-/*  self_pipe.c
+/*  select_self_pipe.c
 
    Employ the self-pipe trick so that we can avoid race conditions while both
    selecting on a set of file descriptors and also waiting for a signal.
 
    Usage as shown in synopsis below; for example:
 
-        self_pipe - 0
+        select_self_pipe - 0
 */
 #include <sys/time.h>
 #if ! defined(__hpux)   /* HP-UX 11 doesn't have this header file */
 #include <sys/select.h>
 #endif
+#include <poll.h>
 #include <fcntl.h>
 #include <signal.h>
 #include "tlpi_hdr.h"
@@ -43,9 +44,10 @@
 int
 main(int argc, char *argv[])
 {
-    fd_set readfds;
+    struct pollfd *pollFds;
     int ready, nfds, flags;
     struct timeval timeout;
+    int pollTimeout;
     struct timeval *pto;
     struct sigaction sa;
     char ch;
@@ -55,29 +57,32 @@
         usageErr("%s {timeout|-} fd...\n"
                 "\t\t('-' means infinite timeout)\n", argv[0]);
 
-    /* Initialize 'timeout', 'readfds', and 'nfds' for select() */
+    /* Initialize 'timeout', 'pollFds', and 'nfds' for poll() */
 
     if (strcmp(argv[1], "-") == 0) {
         pto = NULL;                     /* Infinite timeout */
+        pollTimeout = -1;
     } else {
         pto = &timeout;
         timeout.tv_sec = getLong(argv[1], 0, "timeout");
         timeout.tv_usec = 0;            /* No microseconds */
+        pollTimeout = timeout.tv_sec * 1000;
     }
 
-    nfds = 0;
+    nfds = argc - 2 + 1;                /* fd arguments + pipe */
 
-    /* Build the 'readfds' from the fd numbers given in command line */
+    /* Allocate pollfd array */
+
+    pollFds = calloc(nfds, sizeof(struct pollfd));
+    if (pollFds == NULL)
+        errExit("calloc");
+
+    /* Build the 'pollFds' from the fd numbers given in command line */
 
-    FD_ZERO(&readfds);
     for (j = 2; j < argc; j++) {
         fd = getInt(argv[j], 0, "fd");
-        if (fd >= FD_SETSIZE)
-            cmdLineErr("file descriptor exceeds limit (%d)\n", FD_SETSIZE);
-
-        if (fd >= nfds)
-            nfds = fd + 1;              /* Record maximum fd + 1 */
-        FD_SET(fd, &readfds);
+        pollFds[j - 2].fd = fd;
+        pollFds[j - 2].events = POLLIN;
     }
 
     /* Create pipe before establishing signal handler to prevent race */
@@ -85,8 +90,8 @@
     if (pipe(pfd) == -1)
         errExit("pipe");
 
-    FD_SET(pfd[0], &readfds);           /* Add read end of pipe to 'readfds' */
-    nfds = max(nfds, pfd[0] + 1);       /* And adjust 'nfds' if required */
+    pollFds[nfds - 1].fd = pfd[0];      /* Add read end of pipe to 'pollFds' */
+    pollFds[nfds - 1].events = POLLIN;
 
     /* Make read and write ends of pipe nonblocking */
 
@@ -110,13 +115,13 @@
     if (sigaction(SIGINT, &sa, NULL) == -1)
         errExit("sigaction");
 
-    while ((ready = select(nfds, &readfds, NULL, NULL, pto)) == -1 &&
+    while ((ready = poll(pollFds, nfds, pollTimeout)) == -1 &&
             errno == EINTR)
         continue;                       /* Restart if interrupted by signal */
     if (ready == -1)                    /* Unexpected error */
-        errExit("select");
+        errExit("poll");
 
-    if (FD_ISSET(pfd[0], &readfds)) {   /* Handler was called */
+    if (pollFds[nfds - 1].revents & POLLIN) {   /* Handler was called */
         printf("A signal was caught\n");
 
         for (;;) {                      /* Consume bytes from pipe */
@@ -129,25 +134,33 @@
         }
 
         /* Perform any actions that should be taken in response to signal */
+        printf("Handling signal now!\n");
     }
 
-    /* Examine file descriptor sets returned by select() to see
+    /* Examine file descriptor sets returned by poll() to see
        which other file descriptors are ready */
 
     printf("ready = %d\n", ready);
     for (j = 2; j < argc; j++) {
         fd = getInt(argv[j], 0, "fd");
-        printf("%d: %s\n", fd, FD_ISSET(fd, &readfds) ? "r" : "");
+        if (pollFds[j - 2].revents & POLLIN) {
+            char buffer[256];
+            read(fd, buffer, sizeof(buffer));   /* Drain input */
+            printf("%d: r\n", fd);
+        } else {
+            printf("%d: \n", fd);
+        }
     }
 
     /* And check if read end of pipe is ready */
 
     printf("%d: %s   (read end of pipe)\n", pfd[0],
-            FD_ISSET(pfd[0], &readfds) ? "r" : "");
+            (pollFds[nfds - 1].revents & POLLIN) ? "r" : "");
 
     if (pto != NULL)
         printf("timeout after select(): %ld.%03ld\n",
                (long) timeout.tv_sec, (long) timeout.tv_usec / 1000);
 
+    free(pollFds);
     exit(EXIT_SUCCESS);
 }
```

# Testing

## Regular file descriptior handling (STDIN)
```
$ ./select_self_pipe - 0
test
ready = 1
0: r
3:    (read end of pipe)
```

## Singal handling
```
$ ./select_self_pipe - 0
^CA signal was caught
Handling signal now!
ready = 1
0: 
3: r   (read end of pipe)
$ 
```
