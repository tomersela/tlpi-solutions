A race condition would cause signal loss.

If the program handles the signal first, then drains the pipe, signals arriving during the handling phase would have their pipe bytes consumed by the drain operation without being processed. 

**Example sequence:**
1. `select()` returns. The program begins handling signal A
2. Signal B arrives during handling. The signal handler writes byte to pipe.
3. Program finishes handling A and drains pipe (consuming both A and B bytes)
4. **Signal B is lost** - its pipe byte was consumed but never handled.

By immediately determining how many signals occurred (via byte count), the program commits to handling exactly that many signals Any signals arriving after the drain go to the next `select()` cycle rather than being lost in the current one.

This race only matters if we need exact signal counting. If we accept traditional signal coalescing behavior, the race is harmless since losing signals would be equivalent to normal coalescing.
