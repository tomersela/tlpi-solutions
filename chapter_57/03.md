# Code

## us_seqnum.h
```C
/* us_seqnum.h

   Header file used by us_seqnum_server.c and us_seqnum_client.c

   These programs employ a socket in /tmp. This makes it easy to compile
   and run the programs. However, for a security reasons, a real-world
   application should never create sensitive files in /tmp.
*/
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>

#include "tlpi_hdr.h"

#define SV_SOCK_PATH "/tmp/us_seqnum"

struct request {
    pid_t pid; // pid of client
    int seqLen; // length of desired sequence
};

struct response {
    int seqNum; // start of sequence
};

```

## us_seqnum_server.c
```C
/* us_seqnum_server.c

   An example of a server using a UNIX domain stream socket to handle client requests.
   The "service" provided is the allocation of unique sequential
   numbers. Each client submits a request consisting of its PID, and
   the length of the sequence it is to be allocated by the server.

   The server reads each client request from the socket connection,
   and sends back the starting value of the sequence allocated to that
   client. The server then increments its counter of used numbers
   by the length specified in the client request.

   See us_seqnum.h for the format of request and response messages.

   The client is in us_seqnum_client.c.
*/
#include "us_seqnum.h"

#define BACKLOG 5

int
main(int argc, char *argv[])
{
    struct sockaddr_un addr;
    int sfd, cfd;
    struct request req;
    struct response resp;
    int seqNum = 0;                     /* This is our "service" */

    /* Create server socket */
    
    sfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sfd == -1)
        errExit("socket");

    /* Construct server socket address, bind socket to it,
       and make this a listening socket */

    if (strlen(SV_SOCK_PATH) > sizeof(addr.sun_path) - 1)
        fatal("Server socket path too long: %s", SV_SOCK_PATH);

    if (remove(SV_SOCK_PATH) == -1 && errno != ENOENT)
        errExit("remove-%s", SV_SOCK_PATH);

    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);

    if (bind(sfd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1)
        errExit("bind");

    if (listen(sfd, BACKLOG) == -1)
        errExit("listen");

    for (;;) { // handle client connections

        /* Accept a connection */

        cfd = accept(sfd, NULL, NULL);
        if (cfd == -1)
            errExit("accept");

        /* Read request */

        if (read(cfd, &req, sizeof(struct request)) != sizeof(struct request)) {
            errMsg("Error reading request; closing connection");
            if (close(cfd) == -1)
                errMsg("close");
            continue;
        }

        /* Send response */

        resp.seqNum = seqNum;
        if (write(cfd, &resp, sizeof(struct response)) != sizeof(struct response))
            errMsg("Error writing response");

        seqNum += req.seqLen;           /* Update our sequence number */

        /* Close connection */

        if (close(cfd) == -1)
            errMsg("close");
    }
}

```

## us_seqnum_client.c
```C
/* us_seqnum_client.c

   A simple client that uses a UNIX domain stream socket to request a (trivial)
   "sequence number service". The client connects to the server, sends a request
   consisting of its PID and the length of the sequence it wishes to be allocated
   by the server. The client then reads the server's response and displays it on stdout.

   See us_seqnum.h for the format of request and response messages.

   The server is in us_seqnum_server.c.
*/
#include "us_seqnum.h"

int
main(int argc, char *argv[])
{
    struct sockaddr_un addr;
    int sfd;
    struct request req;
    struct response resp;

    if (argc > 1 && strcmp(argv[1], "--help") == 0)
        usageErr("%s [seq-len]\n", argv[0]);

    /* Create client socket */

    sfd = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sfd == -1)
        errExit("socket");

    /* Construct server address, and make the connection */

    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);

    if (connect(sfd, (struct sockaddr *) &addr,
                sizeof(struct sockaddr_un)) == -1)
        errExit("connect");

    /* Send request to server */

    req.pid = getpid();
    req.seqLen = (argc > 1) ? getInt(argv[1], GN_GT_0, "seq-len") : 1;

    if (write(sfd, &req, sizeof(struct request)) != sizeof(struct request))
        fatal("Can't write to server");

    /* Read and display response */

    if (read(sfd, &resp, sizeof(struct response)) != sizeof(struct response))
        fatal("Can't read response from server");

    printf("%d\n", resp.seqNum);
    exit(EXIT_SUCCESS);
}

```

# Testing
```
$ ./us_seqnum_server &
[1] 7849
$ ./us_seqnum_client 3
0
$ ./us_seqnum_client 2
3
$ ./us_seqnum_client  
5
$ 
```