# Design Considerations

I created kv_store.h and kv_store.c as a separate unit. The implementation uses a simple array of records with linear search (O(n)). Production servers should use more efficient data structures: hash tables (O(1) average), red-black trees or AVL trees (O(log n) with ordering), skip lists (probabilistic O(log n)), B-trees (disk-friendly), or LSM-trees (write-optimized for high throughput).

Records use flexible array members for efficient memory layout (key+value in single allocation). Deletion uses "move last element to fill hole" for O(1) removal.

Binary protocol with network byte order conversion. Fixed headers (opcode, key_len, value_len) followed by variable data. The read_exact() helper handles partial TCP reads.

Client identification by IP address with port-agnostic comparison. All clients can read all records, but only the creator can modify/delete. Production systems need proper authentication.

Multi-threaded implementation - creates a new thread for each client connection. Data structures are mutex-protected for thread safety but use a single global mutex that blocks all operations. Production servers should use thread pools and fine-grained locking (per-key locks, reader-writer locks, or lock-free data structures).

Major limitations: no persistence, no encryption, fixed capacity limits, no transactions. Good enough for the exercise but far from production-ready.


# Code

## kv_store.h
```C
#include <stdint.h>
#include <sys/socket.h>


#define MAX_KEY_LEN 256
#define MAX_VALUE_LEN 4096
#define MAX_RECORDS 1024

#define KV_OK           0
#define KV_ERR_FULL    -1
#define KV_ERR_NOTFOUND -2
#define KV_ERR_NOMEM   -3
#define KV_ERR_PERM    -4 

struct kv_record {
    uint32_t key_len;
    uint32_t value_len;
    struct sockaddr_storage client_addr;
    char data[]; // dynamically allocated [key bytes][value bytes]
};

void kv_store_init(void);
void kv_store_cleanup(void);
int kv_store_set(const char *key, int key_len,const char *value, int value_len, const struct sockaddr_storage *client_addr);
int kv_store_get(const char *key, int key_len, struct kv_record **result);
int kv_store_delete(const char *key, int key_len, const struct sockaddr_storage *client_addr);

```

## kv_store.c
```C
#include <pthread.h>
#include <string.h>
#include <sys/socket.h>
#include <netinet/in.h>

#include "kv_store.h"
#include "tlpi_hdr.h"


static struct kv_record *records[MAX_RECORDS];
static int record_cnt = 0;

static pthread_mutex_t records_mutex = PTHREAD_MUTEX_INITIALIZER;


// compare only IP addresses, ignore ports
static int
same_ip_address(const struct sockaddr_storage *addr1, const struct sockaddr_storage *addr2) {
    if (addr1->ss_family != addr2->ss_family) {
        return 0; // different address families
    }
    
    if (addr1->ss_family == AF_INET) {
        struct sockaddr_in *ipv4_1 = (struct sockaddr_in *)addr1;
        struct sockaddr_in *ipv4_2 = (struct sockaddr_in *)addr2;
        return ipv4_1->sin_addr.s_addr == ipv4_2->sin_addr.s_addr;
    } else if (addr1->ss_family == AF_INET6) {
        struct sockaddr_in6 *ipv6_1 = (struct sockaddr_in6 *)addr1;
        struct sockaddr_in6 *ipv6_2 = (struct sockaddr_in6 *)addr2;
        return memcmp(&ipv6_1->sin6_addr, &ipv6_2->sin6_addr, sizeof(struct in6_addr)) == 0;
    }
    
    return 0; // unsupported address family
}


// WARNING: not thread safe! callers to this function should take care of thread safety
static int
kv_store_get_idx(const char *key, int key_len) {
    for (int i = 0; i < record_cnt; i++) {
        struct kv_record *curr = records[i];
        if (key_len == curr->key_len && memcmp(key, curr->data, key_len) == 0) {
            return i;
        }
    }
    return -1;
}


void
kv_store_init() {
    kv_store_cleanup();
}


void
kv_store_cleanup() {
    pthread_mutex_lock(&records_mutex);
    for (int i = 0; i < record_cnt; i++) {
        free(records[i]);
    }
    record_cnt = 0;  // reset counter after freeing
    pthread_mutex_unlock(&records_mutex);
}


int
kv_store_set(const char *key, int key_len,const char *value, int value_len, const struct sockaddr_storage *client_addr) {
    pthread_mutex_lock(&records_mutex);

    // check for existing record
    int maybe_record_idx = kv_store_get_idx(key, key_len);
    if (maybe_record_idx >= 0) { // record exists
        struct kv_record *existing = records[maybe_record_idx];
        // validate the original creator is the same as the current user (compare IP only, not port)
        if (!same_ip_address(client_addr, &existing->client_addr)) {
            pthread_mutex_unlock(&records_mutex);
            return KV_ERR_PERM;
        }
    } else if (record_cnt >= MAX_RECORDS) { // max capacity reached
        pthread_mutex_unlock(&records_mutex);
        return KV_ERR_FULL;
    }

    struct kv_record *new_record = (struct kv_record *) malloc(sizeof(struct kv_record) + key_len + value_len);
    if (new_record == NULL) { // malloc failed
        pthread_mutex_unlock(&records_mutex);
        return KV_ERR_NOMEM;
    }
    new_record->key_len = key_len;
    new_record->value_len = value_len;
    new_record->client_addr = *client_addr;
    memcpy(new_record->data, key, key_len);
    memcpy(&new_record->data[key_len], value, value_len);

    // check for existing record
    if(maybe_record_idx == -1) {
        records[record_cnt] = new_record;
        record_cnt++;
    } else {
        free(records[maybe_record_idx]); // deallocate existing record
        records[maybe_record_idx] = new_record; // persist new one
    }

    pthread_mutex_unlock(&records_mutex);

    return KV_OK;
}


int
kv_store_get(const char *key, int key_len, struct kv_record **result) {
    pthread_mutex_lock(&records_mutex);

    int maybe_record_idx = kv_store_get_idx(key, key_len);
    if (maybe_record_idx == -1) {
        pthread_mutex_unlock(&records_mutex);
        return KV_ERR_NOTFOUND;
    }

    *result = records[maybe_record_idx];

    pthread_mutex_unlock(&records_mutex);

    return KV_OK;
}


int
kv_store_delete(const char *key, int key_len, const struct sockaddr_storage *client_addr) {
    pthread_mutex_lock(&records_mutex);

    int maybe_record_idx = kv_store_get_idx(key, key_len);
    if (maybe_record_idx == -1) {
        pthread_mutex_unlock(&records_mutex);
        return KV_ERR_NOTFOUND;
    }

    struct kv_record *existing = records[maybe_record_idx];
    // validate the original creator is the same as the current user (compare IP only, not port)
    if (!same_ip_address(client_addr, &existing->client_addr)) {
        pthread_mutex_unlock(&records_mutex);
        return KV_ERR_PERM;
    }

    int last_record_idx = record_cnt - 1;
    if (maybe_record_idx != last_record_idx) { // we're deleting a record within the array (not the last)
        // in order to keep record continuity (other methods in this unit rely on that), we replace the freed record with the last one
        records[maybe_record_idx] = records[last_record_idx];
    }

    record_cnt--;
    free(existing);

    pthread_mutex_unlock(&records_mutex);

    return KV_OK;
}

```

## kv_proto.h
```C
#include <stdint.h>

#define PORT_NUM "9005"

#define OP_GET 1
#define OP_SET 2
#define OP_DELETE 3

#define RES_STATUS_OK 0
#define RES_STATUS_ERR_FULL 1
#define RES_STATUS_ERR_NOTFOUND 2
#define RES_STATUS_ERR_NOMEM 3
#define RES_STATUS_ERR_PERM 4 
#define RES_STATUS_ERR_INVALID_REQ 5
#define RES_STATUS_ERR_INTERNAL 6


struct request_hdr {
    uint32_t opcode;
    uint32_t key_len;
    uint32_t value_len;
};


struct response {
    uint32_t status;
    uint32_t value_len;
    char data[];
};

```

## kv_server.c
```C
#include <pthread.h>
#include <stddef.h>
#include <sys/socket.h>
#include <signal.h>
#include <sys/time.h>

#include "inet_sockets.h"
#include "kv_store.h"
#include "kv_proto.h"
#include "tlpi_hdr.h"

#define BACKLOG_SIZE 10

static size_t
read_exact(int fd, void *buf, size_t n) {
    size_t read_size;
    size_t total_cnt = 0;
    while (total_cnt < n) {
        read_size = read(fd, ((char *) buf) + total_cnt, n - total_cnt);
        if (read_size <= 0) return read_size; // error or EOF
        total_cnt += read_size;
    }
    return total_cnt;
}


static int
parse_request_header(int cfd, struct request_hdr* req_hdr) {
    size_t read_size = 0;
    read_size = read_exact(cfd, req_hdr, sizeof(struct request_hdr));
    if (read_size <= 0) { // Error reading or EOF
        return -1;
    }

    // Convert from network byte order
    req_hdr->opcode = ntohl(req_hdr->opcode);
    req_hdr->key_len = ntohl(req_hdr->key_len);
    req_hdr->value_len = ntohl(req_hdr->value_len);

    if (req_hdr->key_len > MAX_KEY_LEN || req_hdr->value_len > MAX_VALUE_LEN) {
        return RES_STATUS_ERR_INVALID_REQ;
    }

    switch (req_hdr->opcode) {
        case OP_GET:
        case OP_DELETE:
            if (req_hdr->key_len == 0 || req_hdr->value_len != 0)
                return RES_STATUS_ERR_INVALID_REQ;
            break;
        case OP_SET:
            if (req_hdr->key_len == 0 || req_hdr->value_len == 0)
                return RES_STATUS_ERR_INVALID_REQ;
            break;
        default:
            return RES_STATUS_ERR_INVALID_REQ;
    }

    return 0;
}


static void
send_response(int cfd, int kv_result, struct kv_record *record, int opcode) {
    struct response res;

    // Convert kv_store result to protocol response
    switch (kv_result) {
        case KV_OK:
            res.status = htonl(RES_STATUS_OK);
            break;
        case KV_ERR_NOTFOUND:
            res.status = htonl(RES_STATUS_ERR_NOTFOUND);
            break;
        case KV_ERR_NOMEM:
            res.status = htonl(RES_STATUS_ERR_NOMEM);
            break;
        case KV_ERR_PERM:
            res.status = htonl(RES_STATUS_ERR_PERM);
            break;
        case KV_ERR_FULL:
            res.status = htonl(RES_STATUS_ERR_FULL);
            break;
        default:
            errMsg("Unexpected kv_store result: %d", kv_result);
            res.status = htonl(RES_STATUS_ERR_INTERNAL);
            break;
    }
    
    if (kv_result == KV_OK && opcode == OP_GET) {
        // GET success - send value back
        res.value_len = htonl(record->value_len);
        write(cfd, &res, sizeof(res));
        write(cfd, &record->data[record->key_len], record->value_len);
    } else { // error or SET/DELETE success
        res.value_len = 0;
        write(cfd, &res, sizeof(res));
    }
}


static void *
handle_client(void *arg) {
    int cfd = *(int *)arg;
    free(arg); // clean up the malloc'd fd
    
    int hdr_parse_res;
    struct sockaddr_storage claddr;
    struct request_hdr req_hdr;
    struct response res;
    size_t read_size;
    struct kv_record *record;
    int kv_res;

    char key_buffer[MAX_KEY_LEN];
    char value_buffer[MAX_VALUE_LEN];

    // get client address for security checks
    socklen_t alen = sizeof(claddr);
    if (getpeername(cfd, (struct sockaddr *) &claddr, &alen) == -1) {
        errMsg("getpeername");
        close(cfd);
        return NULL;
    }

    // limit connection to 30s to hang slow/hanged clients
    struct timeval timeout = {.tv_sec = 30, .tv_usec = 0};
    setsockopt(cfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

    hdr_parse_res = parse_request_header(cfd, &req_hdr);
    if (hdr_parse_res == -1) {
        errMsg("parse_request_header");
        close(cfd);
        return NULL;
    } else if (hdr_parse_res != 0) {
        res.status = hdr_parse_res;
        res.value_len = 0;
        write(cfd, &res, sizeof(struct response));
        close(cfd);
        return NULL;
    }

    read_size = read_exact(cfd, key_buffer, req_hdr.key_len);
    if (read_size == 0) {
        fprintf(stderr, "read_exact (key) - EOF early than expected\n");
        close(cfd);
        return NULL;
    } else if (read_size == -1) {
        errMsg("read_exact (key)");
        close(cfd);
        return NULL;
    }

    switch (req_hdr.opcode) {
        case OP_GET:
            kv_res = kv_store_get(key_buffer, req_hdr.key_len, &record);
            send_response(cfd, kv_res, record, OP_GET);
            break;

        case OP_SET:
            read_size = read_exact(cfd, value_buffer, req_hdr.value_len);
            if (read_size == 0) {
                fprintf(stderr, "read_exact (value) - EOF early than expected\n");
                close(cfd);
                return NULL;
            } else if (read_size == -1) {
                errMsg("read_exact (value)");
                close(cfd);
                return NULL;
            }
            kv_res = kv_store_set(key_buffer, req_hdr.key_len, value_buffer, req_hdr.value_len, &claddr);
            send_response(cfd, kv_res, NULL, OP_SET);
            break;

        case OP_DELETE:
            kv_res = kv_store_delete(key_buffer, req_hdr.key_len, &claddr);
            send_response(cfd, kv_res, NULL, OP_DELETE);
            break;

        default:
            // shouldn't get here
            errExit("Invalid opcode received for processing");
    }

    close(cfd);
    return NULL;
}


int
main(int argc, char* argvp[]) {
    int cfd;
    struct sockaddr_storage claddr;
    socklen_t addrlen;

    kv_store_init(); // initialize our key/value store

    /* Ignore the SIGPIPE signal, so that we find out about broken connection
       errors via a failure from write(). */
    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) errExit("signal");

    int lfd = inetListen(PORT_NUM, BACKLOG_SIZE, &addrlen);
    if (lfd == -1) {
        fatal("inetListen() failed");
    }

    for (;;) {
        socklen_t alen = sizeof(claddr);
        cfd = accept(lfd, (struct sockaddr *) &claddr, &alen);
        if (cfd == -1) {
            errMsg("accept");
            continue;
        }

        // create thread to handle this client
        pthread_t thread;
        int *client_fd = malloc(sizeof(int));
        if (client_fd == NULL) {
            errMsg("malloc for client_fd");
            close(cfd);
            continue;
        }
        *client_fd = cfd;
        
        if (pthread_create(&thread, NULL, handle_client, client_fd) != 0) {
            errMsg("pthread_create");
            close(cfd);
            free(client_fd);
            continue;
        }
        
        // detach thread so it cleans up automatically when done
        pthread_detach(thread);
    }

    
}

```

## kv_client.c
```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>
#include <getopt.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netdb.h>

#include "kv_proto.h"
#include "tlpi_hdr.h"

static void
print_usage(const char *progname) {
    fprintf(stderr, "Usage: %s [-c client_ip] [-h server_host] <operation> <key> [value]\n", progname);
    fprintf(stderr, "Operations: GET, SET, DELETE\n");
    fprintf(stderr, "  -c client_ip   Client IP to bind to (default: 127.0.0.1)\n");
    fprintf(stderr, "  -h server_host Server hostname/IP (default: localhost)\n");
    fprintf(stderr, "Examples:\n");
    fprintf(stderr, "  %s GET mykey\n", progname);
    fprintf(stderr, "  %s -c 127.0.0.2 SET mykey myvalue\n", progname);
    fprintf(stderr, "  %s -h server.com DELETE mykey\n", progname);
    exit(EXIT_FAILURE);
}

static void
handle_response(int cfd, const char *operation) {
    struct response res;
    if (read(cfd, &res, sizeof(res)) != sizeof(res))
        errExit("read response header");
    
    // convert from network byte order
    res.status = ntohl(res.status);
    res.value_len = ntohl(res.value_len);
    
    // handle response based on status
    if (res.status == RES_STATUS_OK) {
        if (strcmp(operation, "GET") == 0 && res.value_len > 0) {
            // read and display value for GET operation
            char *response_value = malloc(res.value_len + 1);
            if (read(cfd, response_value, res.value_len) != (ssize_t)res.value_len)
                errExit("read response value");
            response_value[res.value_len] = '\0';
            printf("Value: %s\n", response_value);
            free(response_value);
        } else {
            printf("Operation successful\n");
        }
    } else {
        // display error message
        printf("Error: ");
        switch (res.status) {
            case RES_STATUS_ERR_NOTFOUND:
                printf("Key not found\n");
                break;
            case RES_STATUS_ERR_PERM:
                printf("Permission denied\n");
                break;
            case RES_STATUS_ERR_NOMEM:
                printf("Server out of memory\n");
                break;
            case RES_STATUS_ERR_FULL:
                printf("Server storage full\n");
                break;
            case RES_STATUS_ERR_INVALID_REQ:
                printf("Invalid request\n");
                break;
            case RES_STATUS_ERR_INTERNAL:
                printf("Internal server error\n");
                break;
            default:
                printf("Unknown error (%u)\n", res.status);
                break;
        }
    }
}

int
main(int argc, char *argv[]) {
    char *client_ip = "127.0.0.1";
    char *server_host = "localhost";
    char *operation, *key, *value = NULL;
    int opt;
    
    // parse command line options
    while ((opt = getopt(argc, argv, "c:h:")) != -1) {
        switch (opt) {
            case 'c':
                client_ip = optarg;
                break;
            case 'h':
                server_host = optarg;
                break;
            default:
                print_usage(argv[0]);
        }
    }
    
    // check remaining arguments
    if (optind >= argc) {
        fprintf(stderr, "Error: Missing operation\n");
        print_usage(argv[0]);
    }
    
    operation = argv[optind++];
    
    if (optind >= argc) {
        fprintf(stderr, "Error: Missing key\n");
        print_usage(argv[0]);
    }
    
    key = argv[optind++];
    
    // check if operation needs value
    if (strcmp(operation, "SET") == 0) {
        if (optind >= argc) {
            fprintf(stderr, "Error: SET operation requires a value\n");
            print_usage(argv[0]);
        }
        value = argv[optind++];
    }
    
    // Validate operation
    if (strcmp(operation, "GET") != 0 && 
        strcmp(operation, "SET") != 0 && 
        strcmp(operation, "DELETE") != 0) {
        fprintf(stderr, "Error: Invalid operation '%s'. Use GET, SET, or DELETE\n", operation);
        print_usage(argv[0]);
    }
    
    // connecting to the server with socket API (not inetConnect) so we can define
    // the client IP in case that option was specified (-c client_ip)
    struct sockaddr_storage client_addr;
    memset(&client_addr, 0, sizeof(client_addr));

    // try IPv4 first
    struct sockaddr_in *addr4 = (struct sockaddr_in *) &client_addr;
    if (inet_pton(AF_INET, client_ip, &addr4->sin_addr) == 1) {
        addr4->sin_family = AF_INET;
        addr4->sin_port = 0;
        client_addr.ss_family = AF_INET;
    } else {
        // try IPv6
        struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&client_addr;
        if (inet_pton(AF_INET6, client_ip, &addr6->sin6_addr) == 1) {
            addr6->sin6_family = AF_INET6;
            addr6->sin6_port = 0;
            client_addr.ss_family = AF_INET6;
        } else {
            errExit("Invalid IP address");
        }
    }

    int cfd = socket(client_addr.ss_family, SOCK_STREAM, 0);
    if (cfd == -1)
        errExit("socket");

    socklen_t client_len;
    if (client_addr.ss_family == AF_INET) {
        client_len = sizeof(struct sockaddr_in);
    } else {
        client_len = sizeof(struct sockaddr_in6);
    }

    // bind with specific IP
    if (bind(cfd, (struct sockaddr *) &client_addr, client_len) == -1)
        errExit("bind");
    
    // resolve server address
    struct addrinfo hints, *server_info;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family = client_addr.ss_family;  // Match client family (IPv4/IPv6)
    hints.ai_socktype = SOCK_STREAM;
    
    int gai_result = getaddrinfo(server_host, PORT_NUM, &hints, &server_info);
    if (gai_result != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(gai_result));
        exit(EXIT_FAILURE);
    }
    
    // connect to server
    if (connect(cfd, server_info->ai_addr, server_info->ai_addrlen) == -1)
        errExit("connect");
    
    freeaddrinfo(server_info);
    
    // compose and send request
    struct request_hdr req_hdr;
    
    // determine operation code
    if (strcmp(operation, "GET") == 0) {
        req_hdr.opcode = htonl(OP_GET);
    } else if (strcmp(operation, "SET") == 0) {
        req_hdr.opcode = htonl(OP_SET);
    } else if (strcmp(operation, "DELETE") == 0) {
        req_hdr.opcode = htonl(OP_DELETE);
    } else {
        // should never happen due to earlier validation
        errExit("Invalid operation (internal error)");
    }
    
    req_hdr.key_len = htonl(strlen(key));
    req_hdr.value_len = htonl(value ? strlen(value) : 0);
    
    // send request header
    if (write(cfd, &req_hdr, sizeof(req_hdr)) != sizeof(req_hdr))
        errExit("write request header");
    
    // send key
    if (write(cfd, key, strlen(key)) != (ssize_t)strlen(key))
        errExit("write key");
    
    // send value if SET operation
    if (value && write(cfd, value, strlen(value)) != (ssize_t) strlen(value))
        errExit("write value");
    
    // handle server response
    handle_response(cfd, operation);
    
    close(cfd);
    return 0;
}

```

# Testing

For testing different IPs I added another loopback address:
```
$ sudo ip addr add 127.0.0.2/8 dev lo
$ 
```

Then initialized the server:
```
$ ./kv_server &                                    
[1] 29937
```

## Basic SET and GET operations
```
$ ./kv_client SET mykey "hello world"
Operation successful
$ ./kv_client GET mykey
Value: hello world
```

## Update existing key (same IP)
```
$ ./kv_client -c 127.0.0.1 SET mykey "updated value"
Operation successful
$ ./kv_client GET mykey
Value: updated value
```

## Security test - different IP tries to modify
```
$ ./kv_client -c 127.0.0.2 SET mykey "unauthorized change"
Error: Permission denied
```

## GET from different IP (should work)
```
$ ./kv_client -c 127.0.0.2 GET mykey
Value: updated value
```

## DELETE security test
```
$ ./kv_client -c 127.0.0.2 DELETE mykey
Error: Permission denied
$ ./kv_client -c 127.0.0.1 DELETE mykey
Operation successful
$ ./kv_client GET mykey
Error: Key not found
```

## Multiple keys from different IPs
```
$ ./kv_client -c 127.0.0.1 SET key1 "value1"
Operation successful
$ ./kv_client -c 127.0.0.2 SET key2 "value2"
Operation successful
$ ./kv_client -c 127.0.0.1 GET key2
Value: value2
$ ./kv_client -c 127.0.0.1 SET key2 "hack attempt"
Error: Permission denied
```

## GET/DELETE non existing key
```
$ ./kv_client GET nonexistent
Error: Key not found
$ ./kv_client DELETE nonexistent
Error: Key not found
```
