# Code changes

## is_seqnum_mod2.h
```diff
--- ./is_seqnum_mod.h	2025-09-24 00:22:41.324391715 +0300
+++ ./is_seqnum_mod2.h	2025-09-24 00:53:09.134335337 +0300
@@ -17,6 +17,7 @@
 #include <netinet/in.h>
 #include <sys/socket.h>
 #include <signal.h>
+#include "inet_sockets.h"       /* Declares our socket functions */
 #include "read_line_mod.h"          /* Declaration of readLineBuf() */
 #include "tlpi_hdr.h"
 
```

## is_seqnum_sv_mod2.c
```diff
--- ./is_seqnum_sv_mod.c	2025-09-24 01:24:27.306417737 +0300
+++ ./is_seqnum_sv_mod2.c	2025-09-24 01:24:40.887042195 +0300
@@ -8,22 +8,22 @@
 * the file COPYING.gpl-v3 for details.                                    *
 \*************************************************************************/
 
-/* Exercise 59-1 */
+/* Exercise 59-2 */
 
-/* is_seqnum_sv_mod.c
+/* is_seqnum_sv_mod2.c
 
    A simple Internet stream socket server. Our service is to provide
    unique sequence numbers to clients.
 
-   Usage:  is_seqnum_sv [init-seq-num]
+   Usage:  is_seqnum_sv_mod2 [init-seq-num]
                         (default = 0)
 
-   See also is_seqnum_cl_mod.c.
+   See also is_seqnum_cl_mod2.c.
 */
 #define _BSD_SOURCE             /* To get definitions of NI_MAXHOST and
                                    NI_MAXSERV from <netdb.h> */
 #include <netdb.h>
-#include "is_seqnum_mod.h"
+#include "is_seqnum_mod2.h"
 
 #define BACKLOG 50
 
@@ -33,15 +33,10 @@
     uint32_t seqNum;
     char reqLenStr[INT_LEN];            /* Length of requested sequence */
     char seqNumStr[INT_LEN];            /* Start of granted sequence */
-    struct sockaddr_storage claddr;
-    int lfd, cfd, optval, reqLen;
+    int cfd, reqLen;
     socklen_t addrlen;
-    struct addrinfo hints;
-    struct addrinfo *result, *rp;
 #define ADDRSTRLEN (NI_MAXHOST + NI_MAXSERV + 10)
     char addrStr[ADDRSTRLEN];
-    char host[NI_MAXHOST];
-    char service[NI_MAXSERV];
     struct rl_buf rlbuf;
 
     if (argc > 1 && strcmp(argv[1], "--help") == 0)
@@ -54,49 +49,13 @@
 
     if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)    errExit("signal");
 
-    /* Call getaddrinfo() to obtain a list of addresses that
-       we can try binding to */
-
-    memset(&hints, 0, sizeof(struct addrinfo));
-    hints.ai_canonname = NULL;
-    hints.ai_addr = NULL;
-    hints.ai_next = NULL;
-    hints.ai_socktype = SOCK_STREAM;
-    hints.ai_family = AF_UNSPEC;        /* Allows IPv4 or IPv6 */
-    hints.ai_flags = AI_PASSIVE | AI_NUMERICSERV;
-                        /* Wildcard IP address; service name is numeric */
-
-    if (getaddrinfo(NULL, PORT_NUM, &hints, &result) != 0)
-        errExit("getaddrinfo");
-
-    /* Walk through returned list until we find an address structure
-       that can be used to successfully create and bind a socket */
-
-    optval = 1;
-    for (rp = result; rp != NULL; rp = rp->ai_next) {
-        lfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
-        if (lfd == -1)
-            continue;                   /* On error, try next address */
-
-        if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval))
-                == -1)
-             errExit("setsockopt");
-
-        if (bind(lfd, rp->ai_addr, rp->ai_addrlen) == 0)
-            break;                      /* Success */
-
-        /* bind() failed: close this socket and try next address */
-
-        close(lfd);
-    }
-
-    if (rp == NULL)
-        fatal("Could not bind socket to any address");
-
-    if (listen(lfd, BACKLOG) == -1)
-        errExit("listen");
-
-    freeaddrinfo(result);
+    int lfd = inetListen(PORT_NUM, 5, &addrlen);
+    if (lfd == -1)
+        fatal("inetListen() failed");
+    
+    struct sockaddr *claddr = malloc(addrlen);
+    if (claddr == NULL)
+        errExit("malloc");
 
     readLineBufInit(-1, &rlbuf);
 
@@ -104,18 +63,14 @@
 
         /* Accept a client connection, obtaining client's address */
 
-        addrlen = sizeof(struct sockaddr_storage);
-        cfd = accept(lfd, (struct sockaddr *) &claddr, &addrlen);
+        socklen_t alen = addrlen;
+        cfd = accept(lfd, claddr, &alen);
         if (cfd == -1) {
             errMsg("accept");
             continue;
         }
 
-        if (getnameinfo((struct sockaddr *) &claddr, addrlen,
-                    host, NI_MAXHOST, service, NI_MAXSERV, 0) == 0)
-            snprintf(addrStr, ADDRSTRLEN, "(%s, %s)", host, service);
-        else
-            snprintf(addrStr, ADDRSTRLEN, "(?UNKNOWN?)");
+        inetAddressStr(claddr, alen, addrStr, IS_ADDR_STR_LEN);
         printf("Connection from %s\n", addrStr);
 
         /* Read client request, send sequence number back */
```

## is_seqnum_cl_mod2.c
```diff
--- ./is_seqnum_cl_mod.c	2025-09-24 01:02:29.625452850 +0300
+++ ./is_seqnum_cl_mod2.c	2025-09-24 01:22:53.371219698 +0300
@@ -8,9 +8,9 @@
 * the file COPYING.gpl-v3 for details.                                    *
 \*************************************************************************/
 
-/* Exercise 59-1 */
+/* Exercise 59-2 */
 
-/* is_seqnum_cl_mod.c
+/* is_seqnum_cl_mod2.c
 
    A simple Internet stream socket client. This client requests a sequence
    number from the server.
@@ -18,57 +18,22 @@
    See also is_seqnum_sv_mod.c.
 */
 #include <netdb.h>
-#include "is_seqnum_mod.h"
+#include "is_seqnum_mod2.h"
 
 int
 main(int argc, char *argv[])
 {
     char *reqLenStr;                    /* Requested length of sequence */
     char seqNumStr[INT_LEN];            /* Start of granted sequence */
-    int cfd;
     ssize_t numRead;
-    struct addrinfo hints;
-    struct addrinfo *result, *rp;
     struct rl_buf rlbuf;
 
     if (argc < 2 || strcmp(argv[1], "--help") == 0)
         usageErr("%s server-host [sequence-len]\n", argv[0]);
 
-    /* Call getaddrinfo() to obtain a list of addresses that
-       we can try connecting to */
-
-    memset(&hints, 0, sizeof(struct addrinfo));
-    hints.ai_canonname = NULL;
-    hints.ai_addr = NULL;
-    hints.ai_next = NULL;
-    hints.ai_family = AF_UNSPEC;                /* Allows IPv4 or IPv6 */
-    hints.ai_socktype = SOCK_STREAM;
-    hints.ai_flags = AI_NUMERICSERV;
-
-    if (getaddrinfo(argv[1], PORT_NUM, &hints, &result) != 0)
-        errExit("getaddrinfo");
-
-    /* Walk through returned list until we find an address structure
-       that can be used to successfully connect a socket */
-
-    for (rp = result; rp != NULL; rp = rp->ai_next) {
-
-        cfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
-        if (cfd == -1)
-            continue;                   /* On error, try next address */
-
-        if (connect(cfd, rp->ai_addr, rp->ai_addrlen) != -1)
-            break;                              /* Success */
-
-        /* Connect failed: close this socket and try next address */
-
-        close(cfd);
-    }
-
-    if (rp == NULL)
-        fatal("Could not connect socket to any address");
-
-    freeaddrinfo(result);
+    int cfd = inetConnect(argv[1], PORT_NUM, SOCK_STREAM);
+    if (cfd == -1)
+        fatal("inetConnect() failed");
 
     /* Send requested sequence length, with terminating newline */
 
```

# Testing
```
$ ./is_seqnum_sv_mod2 &        
[1] 23779
$ ./is_seqnum_cl_mod2 localhost
Connection from (localhost, 54660)
Sequence number: 0
$ ./is_seqnum_cl_mod2 localhost 10
Connection from (localhost, 54668)
Sequence number: 1
$ ./is_seqnum_cl_mod2 localhost   
Connection from (localhost, 54676)
Sequence number: 11
$
```
