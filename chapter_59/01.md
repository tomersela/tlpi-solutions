# Code changes

## read_line.h
```diff
--- ./read_line.h	2025-09-23 23:47:53.427148402 +0300
+++ ./read_line_mod.h	2025-09-24 00:19:39.076489674 +0300
@@ -8,17 +8,35 @@
 * See the files COPYING.lgpl-v3 and COPYING.gpl-v3 for details.           *
 \*************************************************************************/
 
-/* Header file for Listing 59-1 */
+/* Header file for Exercise 59-1 */
 
-/* read_line.h
+/* read_line_mod.h
 
-   Header file for read_line.c.
+   Header file for read_line_mod.c.
 */
-#ifndef READ_LINE_H
-#define READ_LINE_H
+#ifndef READ_LINE_MOD_H
+#define READ_LINE_MOD_H
 
 #include <sys/types.h>
 
+#define BUF_SIZE 1024
+
+struct rl_buf {
+   int fd;
+   int size;
+   char *buf;
+   char *next;
+   char *end_of_valid_data;
+};
+
 ssize_t readLine(int fd, void *buffer, size_t n);
 
+void readLineBufInit(int fd, struct rl_buf *rlbuf);
+
+ssize_t readLineBuf(struct rl_buf *rlbuf, char *buffer, size_t n);
+
+void resetLineBufInit(int fd, struct rl_buf *rlbuf);
+
+void readLineBufCleanup(struct rl_buf *rlbuf);
+
 #endif
```

## read_line.c
```diff
--- ./read_line.c	2025-09-23 23:47:53.366390788 +0300
+++ ./read_line_mod.c	2025-09-24 00:19:13.151929423 +0300
@@ -10,13 +10,15 @@
 
 /* Listing 59-1 */
 
-/* read_line.c
+/* read_line_mod.c
 
-   Implementation of readLine().
+   Implementation of readLineBuf().
 */
 #include <unistd.h>
+#include <string.h>
 #include <errno.h>
-#include "read_line.h"                  /* Declaration of readLine() */
+#include "read_line_mod.h"                  /* Declaration of readLineBuf() */
+#include <stdlib.h>
 
 /* Read characters from 'fd' until a newline is encountered. If a newline
   character is not encountered in the first (n - 1) bytes, then the excess
@@ -71,3 +73,82 @@
     *buf = '\0';
     return totRead;
 }
+
+void
+readLineBufInit(int fd, struct rl_buf *rlbuf)
+{
+    rlbuf->fd = fd;
+    rlbuf->next = NULL;
+    rlbuf->size = BUF_SIZE;
+    rlbuf->buf = malloc(BUF_SIZE);
+    rlbuf->end_of_valid_data = NULL;
+}
+
+
+ssize_t
+readLineBuf(struct rl_buf *rlbuf, char *buffer, size_t n)
+{
+    size_t read_size;
+    size_t totRead = 0;
+
+    char *buf_curr = buffer;
+    
+    while (totRead < n - 1) {
+        if (rlbuf->next == NULL) {
+            // rlbuf is empty
+            read_size = read(rlbuf->fd, rlbuf->buf, rlbuf->size);
+            if (read_size == -1) return -1;
+            if (read_size == 0) { // EOF
+                if (totRead > 0) { // we've read some data so far
+                    *buf_curr = '\0';
+                    return totRead;
+                }
+                return 0;
+            }
+            rlbuf->next = rlbuf->buf;
+            rlbuf->end_of_valid_data = rlbuf->buf + read_size;
+        }
+
+        // find the end of next line in the buffer
+        char *newline_pos = memchr(rlbuf->next, '\n', rlbuf->end_of_valid_data - rlbuf->next);
+        if (newline_pos) {
+            // copy the data up to the newline
+            memcpy(buf_curr, rlbuf->next, newline_pos - rlbuf->next + 1);
+            totRead += newline_pos - rlbuf->next + 1;
+            buf_curr += newline_pos - rlbuf->next + 1;
+            *buf_curr = '\0';
+            rlbuf->next = newline_pos + 1;
+            return totRead;
+        }
+
+        // no newline in the buffer
+        // copy the entire buffer and set buffer to empty
+        size_t available_in_buffer = rlbuf->end_of_valid_data - rlbuf->next;
+        size_t space_in_output = n - 1 - totRead;
+        size_t max_copy = (available_in_buffer > space_in_output) ? space_in_output : available_in_buffer;
+        memcpy(buf_curr, rlbuf->next, max_copy);
+        totRead += max_copy;
+        buf_curr += max_copy;
+        rlbuf->next = NULL; // need refill; set buffer to empty   
+    }
+
+    *buf_curr = '\0';
+    return totRead - 1;
+}
+
+
+void
+resetLineBufInit(int fd, struct rl_buf *rlbuf)
+{
+    rlbuf->fd = fd;
+    rlbuf->next = NULL;
+}
+
+void
+readLineBufCleanup(struct rl_buf *rlbuf)
+{
+    if (rlbuf->buf != NULL) {
+        free(rlbuf->buf);
+        rlbuf->buf = NULL;
+    }
+}
```

## is_seqnum_mod.h
```diff
--- ./is_seqnum.h	2025-09-20 00:16:14.700401358 +0300
+++ ./is_seqnum_mod.h	2025-09-24 00:22:41.324391715 +0300
@@ -8,16 +8,16 @@
 * the file COPYING.gpl-v3 for details.                                    *
 \*************************************************************************/
 
-/* Listing 59-5 */
+/* Exercise 59-1 */
 
-/* is_seqnum.h
+/* is_seqnum_mod.h
 
-   Header file for is_seqnum_sv.c and is_seqnum_cl.c.
+   Header file for is_seqnum_sv_mod.c and is_seqnum_cl_mod.c.
 */
 #include <netinet/in.h>
 #include <sys/socket.h>
 #include <signal.h>
-#include "read_line.h"          /* Declaration of readLine() */
+#include "read_line_mod.h"          /* Declaration of readLineBuf() */
 #include "tlpi_hdr.h"
 
 #define PORT_NUM "50000"        /* Port number for server */
```

## is_seqnum_sv_mod.c
```diff
--- ./is_seqnum_sv.c	2025-09-20 00:16:14.776559975 +0300
+++ ./is_seqnum_sv_mod.c	2025-09-24 00:20:00.852470384 +0300
@@ -8,9 +8,9 @@
 * the file COPYING.gpl-v3 for details.                                    *
 \*************************************************************************/
 
-/* Listing 59-6 */
+/* Exercise 59-1 */
 
-/* is_seqnum_sv.c
+/* is_seqnum_sv_mod.c
 
    A simple Internet stream socket server. Our service is to provide
    unique sequence numbers to clients.
@@ -18,12 +18,12 @@
    Usage:  is_seqnum_sv [init-seq-num]
                         (default = 0)
 
-   See also is_seqnum_cl.c.
+   See also is_seqnum_cl_mod.c.
 */
 #define _BSD_SOURCE             /* To get definitions of NI_MAXHOST and
                                    NI_MAXSERV from <netdb.h> */
 #include <netdb.h>
-#include "is_seqnum.h"
+#include "is_seqnum_mod.h"
 
 #define BACKLOG 50
 
@@ -42,6 +42,7 @@
     char addrStr[ADDRSTRLEN];
     char host[NI_MAXHOST];
     char service[NI_MAXSERV];
+    struct rl_buf rlbuf;
 
     if (argc > 1 && strcmp(argv[1], "--help") == 0)
         usageErr("%s [init-seq-num]\n", argv[0]);
@@ -97,6 +98,8 @@
 
     freeaddrinfo(result);
 
+    readLineBufInit(-1, &rlbuf);
+
     for (;;) {                  /* Handle clients iteratively */
 
         /* Accept a client connection, obtaining client's address */
@@ -117,7 +120,8 @@
 
         /* Read client request, send sequence number back */
 
-        if (readLine(cfd, reqLenStr, INT_LEN) <= 0) {
+        resetLineBufInit(cfd, &rlbuf);
+        if (readLineBuf(&rlbuf, reqLenStr, INT_LEN) <= 0) {
             close(cfd);
             continue;                   /* Failed read; skip request */
         }
@@ -137,4 +141,7 @@
         if (close(cfd) == -1)           /* Close connection */
             errMsg("close");
     }
+
+    /* This line is never reached, but good practice to clean up */
+    readLineBufCleanup(&rlbuf);
 }
```

## is_seqnum_cl_mod.c
```diff
--- ./is_seqnum_cl.c	2025-09-20 00:16:14.842513091 +0300
+++ ./is_seqnum_cl_mod.c	2025-09-24 00:20:16.156031904 +0300
@@ -8,17 +8,17 @@
 * the file COPYING.gpl-v3 for details.                                    *
 \*************************************************************************/
 
-/* Listing 59-7 */
+/* Exercise 59-1 */
 
-/* is_seqnum_cl.c
+/* is_seqnum_cl_mod.c
 
    A simple Internet stream socket client. This client requests a sequence
    number from the server.
 
-   See also is_seqnum_sv.c.
+   See also is_seqnum_sv_mod.c.
 */
 #include <netdb.h>
-#include "is_seqnum.h"
+#include "is_seqnum_mod.h"
 
 int
 main(int argc, char *argv[])
@@ -29,6 +29,7 @@
     ssize_t numRead;
     struct addrinfo hints;
     struct addrinfo *result, *rp;
+    struct rl_buf rlbuf;
 
     if (argc < 2 || strcmp(argv[1], "--help") == 0)
         usageErr("%s server-host [sequence-len]\n", argv[0]);
@@ -78,8 +79,8 @@
         fatal("Partial/failed write (newline)");
 
     /* Read and display sequence number returned by server */
-
-    numRead = readLine(cfd, seqNumStr, INT_LEN);
+    readLineBufInit(cfd, &rlbuf);
+    numRead = readLineBuf(&rlbuf, seqNumStr, INT_LEN);
     if (numRead == -1)
         errExit("readLine");
     if (numRead == 0)
@@ -87,5 +88,6 @@
 
     printf("Sequence number: %s", seqNumStr);   /* Includes '\n' */
 
+    readLineBufCleanup(&rlbuf);                 /* Clean up allocated buffer (not needed, but good practice) */
     exit(EXIT_SUCCESS);                         /* Closes 'cfd' */
 }
```

# Testing
```
$ ./is_seqnum_sv_mod &           
[1] 19575
$ ./is_seqnum_cl_mod localhost
Connection from (localhost, 39636)
Sequence number: 0
$ ./is_seqnum_cl_mod localhost 10
Connection from (localhost, 39642)
Sequence number: 1
$ ./is_seqnum_cl_mod localhost   
Connection from (localhost, 39650)
Sequence number: 11
$ 
```
