# UNIX domain sockets library

## unix_sockets.h
```C
#ifndef UNIX_SOCKETS_H
#define UNIX_SOCKETS_H          /* Prevent accidental double inclusion */

#include <sys/socket.h>
#include <sys/un.h>

/* Connect to UNIX domain socket at 'path' with specified 'type' 
   (SOCK_STREAM or SOCK_DGRAM). Return socket descriptor on success, 
   or -1 on error */
int unixConnect(const char *path, int type);

/* Create UNIX domain socket bound to 'path'. Make it a listening socket
   with specified 'backlog'. Return socket descriptor on success, 
   or -1 on error */
int unixListen(const char *path, int backlog);

/* Create UNIX domain socket bound to 'path' with specified 'type'.
   Return socket descriptor on success, or -1 on error */
int unixBind(const char *path, int type);

/* Format UNIX domain socket address as a string. Return formatted string
   in 'addrStr' buffer of size 'addrStrLen'. Also returns 'addrStr' as
   function result */
char *unixAddressStr(const struct sockaddr *addr, socklen_t addrlen,
                     char *addrStr, int addrStrLen);

/* Remove socket file from filesystem. Should be called by server
   when shutting down to clean up socket file */
int unixRemove(const char *path);

#define US_ADDR_STR_LEN 1024    /* Suggested length for string buffer that
                                   caller should pass to unixAddressStr() */
#endif

```

## unix_sockets.c
```C
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include "unix_sockets.h"

#include "tlpi_hdr.h"


/* Create socket and connect it to the UNIX domain socket at 'path'.
   Return socket descriptor on success, or -1 on error */
int
unixConnect(const char *path, int type)
{
    struct sockaddr_un addr;
    int sfd;

    sfd = socket(AF_UNIX, type, 0);
    if (sfd == -1)
        return -1;

    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    
    if (strlen(path) >= sizeof(addr.sun_path)) {
        close(sfd);
        errno = ENAMETOOLONG;
        return -1;
    }
    
    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);

    if (connect(sfd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1) {
        int savedErrno = errno;
        close(sfd);
        errno = savedErrno;
        return -1;
    }

    return sfd;
}


/* Create a UNIX domain socket and bind it to 'path'.
   If 'doListen' is TRUE, make this a listening socket with 'backlog'.
   Return socket descriptor on success, or -1 on error */
static int
unixPassiveSocket(const char *path, int type, Boolean doListen, int backlog)
{
    struct sockaddr_un addr;
    int sfd;

    sfd = socket(AF_UNIX, type, 0);
    if (sfd == -1)
        return -1;

    /* Remove any existing socket file to avoid bind() failing */
    if (unlink(path) == -1 && errno != ENOENT) {
        int savedErrno = errno;
        close(sfd);
        errno = savedErrno;
        return -1;
    }

    memset(&addr, 0, sizeof(struct sockaddr_un));
    addr.sun_family = AF_UNIX;
    
    if (strlen(path) >= sizeof(addr.sun_path)) {
        close(sfd);
        errno = ENAMETOOLONG;
        return -1;
    }
    
    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);

    if (bind(sfd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1) {
        int savedErrno = errno;
        close(sfd);
        errno = savedErrno;
        return -1;
    }

    if (doListen) {
        if (listen(sfd, backlog) == -1) {
            int savedErrno = errno;
            close(sfd);
            unlink(path);  /* Clean up socket file */
            errno = savedErrno;
            return -1;
        }
    }

    return sfd;
}


/* Create stream socket, bound to 'path'. Make the socket a listening socket,
   with the specified 'backlog'. Return socket descriptor on success, 
   or -1 on error */
int
unixListen(const char *path, int backlog)
{
    return unixPassiveSocket(path, SOCK_STREAM, TRUE, backlog);
}


/* Create socket bound to 'path' with specified 'type'.
   Return socket descriptor on success, or -1 on error */
int
unixBind(const char *path, int type)
{
    return unixPassiveSocket(path, type, FALSE, 0);
}


/* Given a UNIX domain socket address in 'addr', return a null-terminated 
   string containing the socket path in the form "unix:path". The string is
   returned in the buffer pointed to by 'addrStr', and this value is also
   returned as the function result. The caller must specify the size of the
   'addrStr' buffer in 'addrStrLen' */
char *
unixAddressStr(const struct sockaddr *addr, socklen_t addrlen, char *addrStr, int addrStrLen)
{
    struct sockaddr_un *unAddr = (struct sockaddr_un *) addr;

    if (addr->sa_family == AF_UNIX) {
        if (unAddr->sun_path[0] == '\0') {
            /* Abstract socket */
            snprintf(addrStr, addrStrLen, "unix:@%.*s", 
                    (int)(addrlen - sizeof(sa_family_t) - 1), 
                    &unAddr->sun_path[1]);
        } else {
            /* Pathname socket */
            snprintf(addrStr, addrStrLen, "unix:%s", unAddr->sun_path);
        }
    } else {
        snprintf(addrStr, addrStrLen, "unix:?UNKNOWN?");
    }

    return addrStr;
}


/* Remove socket file from filesystem. Should be called by server
   when shutting down to clean up socket file */
int
unixRemove(const char *path)
{
    return unlink(path);
}

```


# Code changes

## us_xfr_cl_mod.c
```diff
--- ./us_xfr_cl.c	2025-09-24 01:48:27.474482212 +0300
+++ ./us_xfr_cl_mod.c	2025-09-24 01:53:45.240100734 +0300
@@ -8,38 +8,28 @@
 * the file COPYING.gpl-v3 for details.                                    *
 \*************************************************************************/
 
-/* Listing 57-4 */
+/* Exercise 59-3 */
 
-/* us_xfr_cl.c
+/* us_xfr_cl_mod.c
 
    An example UNIX domain stream socket client. This client transmits contents
    of stdin to a server socket.
 
-   See also us_xfr_sv.c.
+   See also us_xfr_sv_mod.c.
 */
 #include "us_xfr.h"
+#include "unix_sockets.h"
 
 int
 main(int argc, char *argv[])
 {
-    struct sockaddr_un addr;
     int sfd;
     ssize_t numRead;
     char buf[BUF_SIZE];
 
-    sfd = socket(AF_UNIX, SOCK_STREAM, 0);      /* Create client socket */
+    sfd = unixConnect(SV_SOCK_PATH, SOCK_STREAM);
     if (sfd == -1)
-        errExit("socket");
-
-    /* Construct server address, and make the connection */
-
-    memset(&addr, 0, sizeof(struct sockaddr_un));
-    addr.sun_family = AF_UNIX;
-    strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);
-
-    if (connect(sfd, (struct sockaddr *) &addr,
-                sizeof(struct sockaddr_un)) == -1)
-        errExit("connect");
+        errExit("unixConnect");
 
     /* Copy stdin to socket */
 
```

## us_xfr_sv_mod.c
```diff
--- ./us_xfr_sv.c	2025-09-24 01:48:27.519739361 +0300
+++ ./us_xfr_sv_mod.c	2025-09-24 01:53:32.758162867 +0300
@@ -8,51 +8,29 @@
 * the file COPYING.gpl-v3 for details.                                    *
 \*************************************************************************/
 
-/* Listing 57-3 */
+/* Exercise 59-3 */
 
-/* us_xfr_sv.c
+/* us_xfr_sv_mod.c
 
    An example UNIX stream socket server. Accepts incoming connections
    and copies data sent from clients to stdout.
 
-   See also us_xfr_cl.c.
+   See also us_xfr_cl_mod.c.
 */
 #include "us_xfr.h"
+#include "unix_sockets.h"
 #define BACKLOG 5
 
 int
 main(int argc, char *argv[])
 {
-    struct sockaddr_un addr;
     int sfd, cfd;
     ssize_t numRead;
     char buf[BUF_SIZE];
 
-    sfd = socket(AF_UNIX, SOCK_STREAM, 0);
+    sfd = unixListen(SV_SOCK_PATH, BACKLOG);
     if (sfd == -1)
-        errExit("socket");
-
-    /* Construct server socket address, bind socket to it,
-       and make this a listening socket */
-
-    /* For an explanation of the following check, see the errata notes for
-       pages 1168 and 1172 at http://www.man7.org/tlpi/errata/. */
-
-    if (strlen(SV_SOCK_PATH) > sizeof(addr.sun_path) - 1)
-        fatal("Server socket path too long: %s", SV_SOCK_PATH);
-
-    if (remove(SV_SOCK_PATH) == -1 && errno != ENOENT)
-        errExit("remove-%s", SV_SOCK_PATH);
-
-    memset(&addr, 0, sizeof(struct sockaddr_un));
-    addr.sun_family = AF_UNIX;
-    strncpy(addr.sun_path, SV_SOCK_PATH, sizeof(addr.sun_path) - 1);
-
-    if (bind(sfd, (struct sockaddr *) &addr, sizeof(struct sockaddr_un)) == -1)
-        errExit("bind");
-
-    if (listen(sfd, BACKLOG) == -1)
-        errExit("listen");
+        errExit("unixListen");
 
     for (;;) {          /* Handle client connections iteratively */
 
@@ -76,4 +54,7 @@
         if (close(cfd) == -1)
             errMsg("close");
     }
+
+    /* Clean up socket file on exit (never reached, but good practice) */
+    unixRemove(SV_SOCK_PATH);
 }
```


# Testing
```
$ ./us_xfr_sv_mod > b &
[1] 24832
$ ls -lF /tmp/us_xfr
srwxr-xr-x 1 debian debian 0 Sep 24 02:01 /tmp/us_xfr=
$ cat *.c > a
$ ./us_xfr_cl_mod < a
$ kill %1
[1]  + 24832 terminated  ./us_xfr_sv_mod > b                                                                          
$ diff a b
$ rm a b
$ 
```
